"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-conic-polygon-geometry";
exports.ids = ["vendor-chunks/three-conic-polygon-geometry"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ConicPolygonGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/merge.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/mean.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/extent.js\");\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"(ssr)/./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var delaunator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! delaunator */ \"(ssr)/./node_modules/delaunator/index.js\");\n/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ \"(ssr)/./node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/bounds.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/distance.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/interpolate.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/contains.js\");\n/* harmony import */ var d3_geo_voronoi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo-voronoi */ \"(ssr)/./node_modules/d3-geo-voronoi/src/voronoi.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/linear.js\");\n\n\n\n\n\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertThisInitialized(e) {\n  if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === undefined ? Infinity : _ref$resolution;\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(boundariesGeojson),\n    _geoBounds2 = _slicedToArray(_geoBounds, 2),\n    _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n    minLng = _geoBounds2$[0],\n    minLat = _geoBounds2$[1],\n    _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n    maxLng = _geoBounds2$2[0],\n    maxLat = _geoBounds2$2[1];\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = (0,d3_geo_voronoi__WEBPACK_IMPORTED_MODULE_3__.geoVoronoi)(points).triangles(); // geoDelaunay generates more triangles than needed\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        lng = _ref3[0],\n        lat = _ref3[1];\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          lng = _ref5[0],\n          lat = _ref5[1];\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcutFlatten = (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)(contour),\n      vertices = _earcutFlatten.vertices,\n      _earcutFlatten$holes = _earcutFlatten.holes,\n      holes = _earcutFlatten$holes === undefined ? [] : _earcutFlatten$holes;\n    indices = (0,earcut__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(vertices, holes, 2);\n  } else {\n    // use delaunator\n    var delaunay = delaunator__WEBPACK_IMPORTED_MODULE_4__[\"default\"].from(points);\n    var _loop = function _loop(i) {\n      var _indices2;\n      var inds = [2, 1, 0].map(function (idx) {\n        return delaunay.triangles[i + idx];\n      }); // reverse wound to have same orientation as earcut\n      var triangle = inds.map(function (indice) {\n        return points[indice];\n      });\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = [0, 1].map(function (coordIdx) {\n          return (0,d3_array__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(triangle, function (p) {\n            return p[coordIdx];\n          });\n        });\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return 1; // continue\n      }\n      (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n    };\n    for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n      if (_loop(i)) continue;\n    }\n  }\n\n  // calc uvs\n  var lngUvScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((0,d3_array__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(points, function (d) {\n    return d[0];\n  }), [0, 1]);\n  var latUvScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_6__[\"default\"])((0,d3_array__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(points, function (d) {\n    return d[1];\n  }), [0, 1]);\n  var uvs = points.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      lng = _ref7[0],\n      lat = _ref7[1];\n    return [lngUvScale(lng), latUvScale(lat)];\n  });\n  var triangles = {\n    points: points,\n    indices: indices,\n    uvs: uvs\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = (0,d3_geo__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(pnt, prevPnt) * 180 / Math.PI;\n        if (dist > maxDistance) {\n          var interpol = (0,d3_geo__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds3 = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(boundariesGeojson),\n    _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n    _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n    minLng = _geoBounds4$[0],\n    minLat = _geoBounds4$[1],\n    _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n    maxLng = _geoBounds4$2[0],\n    maxLat = _geoBounds4$2[1];\n\n  // polygon smaller than maxDistance -> no inner points\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    minLng = _ref8.minLng,\n    maxLng = _ref8.maxLng,\n    minLat = _ref8.minLat,\n    maxLat = _ref8.maxLat;\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);\n\n  // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n  return pnts;\n}\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? (0,d3_geo__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(polygon, pnt) : (0,_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: three__WEBPACK_IMPORTED_MODULE_12__.BufferGeometry,\n  Float32BufferAttribute: three__WEBPACK_IMPORTED_MODULE_12__.Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar ConicPolygonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  function ConicPolygonGeometry(polygonGeoJson, bottomHeight, topHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n    _classCallCheck(this, ConicPolygonGeometry);\n    _this = _callSuper(this, ConicPolygonGeometry);\n    _this.type = 'ConicPolygonGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      bottomHeight: bottomHeight,\n      topHeight: topHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    };\n\n    // defaults\n    bottomHeight = bottomHeight || 0;\n    topHeight = topHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n\n    // pre-calculate contour, triangulation and UV maps\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n        resolution: curvatureResolution\n      }),\n      contour = _geoPolygonTriangulat.contour,\n      triangles = _geoPolygonTriangulat.triangles;\n    var flatUvs = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(triangles.uvs);\n    var vertices = [];\n    var uvs = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      uvs = uvs.concat(groupData.uvs);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(bottomHeight, false));\n    closedTop && addGroup(generateCap(topHeight, true));\n\n    // build geometry\n    _this.setIndex(indices);\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n    _this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\n    // auto-calculate normals\n    _this.computeVertexNormals();\n\n    //\n\n    function generateVertices(polygon, altitude) {\n      var altFn = typeof altitude === 'function' ? altitude : function () {\n        return altitude;\n      };\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n          return polar2Cartesian(lat, lng, altFn(lng, lat));\n        });\n      });\n      // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n      return (0,earcut__WEBPACK_IMPORTED_MODULE_0__.flatten)(coords3d);\n    }\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, bottomHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n      var _generateVertices2 = generateVertices(contour, topHeight),\n        topVerts = _generateVertices2.vertices;\n      var vertices = (0,d3_array__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n          lastHoleIdx = holeIdx;\n        }\n\n        // Each pair of coords generates two triangles (faces)\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n      var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n      for (var v = 1; v >= 0; v--) for (var i = 0; i < numPoints; i += 1) uvs.push(i / (numPoints - 1), v);\n      return {\n        indices: indices,\n        vertices: vertices,\n        uvs: uvs\n      };\n    }\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices,\n        uvs: flatUvs\n      };\n    }\n    return _this;\n  }\n  _inherits(ConicPolygonGeometry, _THREE$BufferGeometry);\n  return _createClass(ConicPolygonGeometry);\n}(THREE.BufferGeometry); //\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtY29uaWMtcG9seWdvbi1nZW9tZXRyeS9kaXN0L3RocmVlLWNvbmljLXBvbHlnb24tZ2VvbWV0cnkubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStEO0FBQ2hCO0FBQ047QUFDTDtBQUM0QjtBQUNhO0FBQ2pDO0FBQ0w7O0FBRXZDO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHlGQUF5RjtBQUN6RixJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWSxrRUFBa0U7QUFDN0gsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9EQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNULE9BQU87QUFDUCxtQkFBbUIsOEJBQThCO0FBQ2pELGFBQWEsK0NBQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0RBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLCtCQUErQjtBQUMvQjtBQUNBLCtCQUErQjtBQUMvQixVQUFVO0FBQ1Y7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixzQkFBc0IsUUFBUSxxQkFBcUIsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDIiwic291cmNlcyI6WyIvVXNlcnMvc3VyYWpyYXdhdC9Eb3dubG9hZHMvVHJpcHkvbm9kZV9tb2R1bGVzL3RocmVlLWNvbmljLXBvbHlnb24tZ2VvbWV0cnkvZGlzdC90aHJlZS1jb25pYy1wb2x5Z29uLWdlb21ldHJ5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IG1lcmdlLCBleHRlbnQsIG1lYW4gfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgZWFyY3V0LCB7IGZsYXR0ZW4gfSBmcm9tICdlYXJjdXQnO1xuaW1wb3J0IERlbGF1bmF0b3IgZnJvbSAnZGVsYXVuYXRvcic7XG5pbXBvcnQgdHVyZlBvaW50SW5Qb2x5Z29uIGZyb20gJ0B0dXJmL2Jvb2xlYW4tcG9pbnQtaW4tcG9seWdvbic7XG5pbXBvcnQgeyBnZW9Cb3VuZHMsIGdlb0NvbnRhaW5zLCBnZW9EaXN0YW5jZSwgZ2VvSW50ZXJwb2xhdGUgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgZ2VvVm9yb25vaSB9IGZyb20gJ2QzLWdlby12b3Jvbm9pJztcbmltcG9ydCB7IHNjYWxlTGluZWFyIH0gZnJvbSAnZDMtc2NhbGUnO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodW5kZWZpbmVkID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBbXSwgX2dldFByb3RvdHlwZU9mKHQpLmNvbnN0cnVjdG9yKSA6IG8uYXBwbHkodCwgZSkpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIF9nZXRQcm90b3R5cGVPZih0KTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gdHJ1ZSxcbiAgICAgIG8gPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgOyBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSB0cnVlLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdC5yZXR1cm4gJiYgKHUgPSB0LnJldHVybigpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHVuZGVmaW5lZCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VvUG9seWdvblRyaWFuZ3VsYXRlKHBvbHlnb24pIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgIF9yZWYkcmVzb2x1dGlvbiA9IF9yZWYucmVzb2x1dGlvbixcbiAgICByZXNvbHV0aW9uID0gX3JlZiRyZXNvbHV0aW9uID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IF9yZWYkcmVzb2x1dGlvbjtcbiAgdmFyIGNvbnRvdXIgPSBpbnRlcnBvbGF0ZUNvbnRvdXJQb2ludHMocG9seWdvbiwgcmVzb2x1dGlvbik7XG4gIHZhciBlZGdlUG9pbnRzID0gbWVyZ2UoY29udG91cik7XG4gIHZhciBpbm5lclBvaW50cyA9IGdldElubmVyR2VvUG9pbnRzKHBvbHlnb24sIHJlc29sdXRpb24pO1xuICB2YXIgcG9pbnRzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShlZGdlUG9pbnRzKSwgX3RvQ29uc3VtYWJsZUFycmF5KGlubmVyUG9pbnRzKSk7XG4gIHZhciBib3VuZGFyaWVzR2VvanNvbiA9IHtcbiAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IHBvbHlnb25cbiAgfTtcbiAgdmFyIF9nZW9Cb3VuZHMgPSBnZW9Cb3VuZHMoYm91bmRhcmllc0dlb2pzb24pLFxuICAgIF9nZW9Cb3VuZHMyID0gX3NsaWNlZFRvQXJyYXkoX2dlb0JvdW5kcywgMiksXG4gICAgX2dlb0JvdW5kczIkID0gX3NsaWNlZFRvQXJyYXkoX2dlb0JvdW5kczJbMF0sIDIpLFxuICAgIG1pbkxuZyA9IF9nZW9Cb3VuZHMyJFswXSxcbiAgICBtaW5MYXQgPSBfZ2VvQm91bmRzMiRbMV0sXG4gICAgX2dlb0JvdW5kczIkMiA9IF9zbGljZWRUb0FycmF5KF9nZW9Cb3VuZHMyWzFdLCAyKSxcbiAgICBtYXhMbmcgPSBfZ2VvQm91bmRzMiQyWzBdLFxuICAgIG1heExhdCA9IF9nZW9Cb3VuZHMyJDJbMV07XG4gIHZhciBjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuID0gbWluTG5nID4gbWF4TG5nIC8vIGNyb3NzZXMgYW50aW1lcmlkaWFuXG4gIHx8IG1heExhdCA+PSA4OSAvLyBjcm9zc2VzIG5vcnRoIHBvbGVcbiAgfHwgbWluTGF0IDw9IC04OTsgLy8gY3Jvc3NlcyBzb3V0aCBwb2xlXG5cbiAgdmFyIGluZGljZXMgPSBbXTtcbiAgaWYgKGNyb3NzZXNQb2xlT3JBbnRpbWVyaWRpYW4pIHtcbiAgICAvLyBVc2UgZDMtZ2VvLXZvcm9ub2kuIFNsb3dlc3QsIGJ1dCBtb3N0IGFjY3VyYXRlIGZvciBwb2x5Z29ucyB0aGF0IGNyb3NzIHBvbGVzIG9yIGFudGktbWVyaWRpYW5cbiAgICB2YXIgdnQgPSBnZW9Wb3Jvbm9pKHBvaW50cykudHJpYW5nbGVzKCk7IC8vIGdlb0RlbGF1bmF5IGdlbmVyYXRlcyBtb3JlIHRyaWFuZ2xlcyB0aGFuIG5lZWRlZFxuICAgIHZhciBwbnRNYXAgPSBuZXcgTWFwKHBvaW50cy5tYXAoZnVuY3Rpb24gKF9yZWYyLCBpZHgpIHtcbiAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgbG5nID0gX3JlZjNbMF0sXG4gICAgICAgIGxhdCA9IF9yZWYzWzFdO1xuICAgICAgcmV0dXJuIFtcIlwiLmNvbmNhdChsbmcsIFwiLVwiKS5jb25jYXQobGF0KSwgaWR4XTtcbiAgICB9KSk7XG4gICAgdnQuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgdmFyIF9pbmRpY2VzO1xuICAgICAgdmFyIHRyaWFuZ2xlID0gZi5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5zbGljZSgwLCAzKS5yZXZlcnNlKCk7IC8vIHJldmVyc2Ugd291bmQgdG8gbWF0Y2ggZWFyY3V0XG5cbiAgICAgIHZhciBpbmRzID0gW107XG4gICAgICB0cmlhbmdsZS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgX3JlZjUgPSBfc2xpY2VkVG9BcnJheShfcmVmNCwgMiksXG4gICAgICAgICAgbG5nID0gX3JlZjVbMF0sXG4gICAgICAgICAgbGF0ID0gX3JlZjVbMV07XG4gICAgICAgIHZhciBrID0gXCJcIi5jb25jYXQobG5nLCBcIi1cIikuY29uY2F0KGxhdCk7XG4gICAgICAgIHBudE1hcC5oYXMoaykgJiYgaW5kcy5wdXNoKHBudE1hcC5nZXQoaykpO1xuICAgICAgfSk7XG4gICAgICBpZiAoaW5kcy5sZW5ndGggIT09IDMpIHJldHVybjsgLy8gdHJpYW5nbGUgbWFsZnVuY3Rpb25cblxuICAgICAgLy8gZXhjbHVkZSBlZGdlIHRyaWFuZ2xlcyBvdXRzaWRlIHBvbHlnb24gcGVyaW1ldGVyIG9yIHRocm91Z2ggaG9sZXNcbiAgICAgIGlmIChpbmRzLnNvbWUoZnVuY3Rpb24gKGluZCkge1xuICAgICAgICByZXR1cm4gaW5kIDwgZWRnZVBvaW50cy5sZW5ndGg7XG4gICAgICB9KSkge1xuICAgICAgICB2YXIgdHJpYW5nbGVDZW50cm9pZCA9IGYucHJvcGVydGllcy5jaXJjdW1jZW50ZXI7XG4gICAgICAgIGlmICghcG9pbnRJbnNpZGUodHJpYW5nbGVDZW50cm9pZCwgYm91bmRhcmllc0dlb2pzb24sIGNyb3NzZXNQb2xlT3JBbnRpbWVyaWRpYW4pKSByZXR1cm47XG4gICAgICB9XG4gICAgICAoX2luZGljZXMgPSBpbmRpY2VzKS5wdXNoLmFwcGx5KF9pbmRpY2VzLCBpbmRzKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICghaW5uZXJQb2ludHMubGVuZ3RoKSB7XG4gICAgLy8gZWFyY3V0IHRyaWFuZ3VsYXRpb24gc2xpZ2h0bHkgbW9yZSBwZXJmb3JtaW5nIGlmIGl0J3Mgb25seSB1c2luZyB0aGUgcG9seWdvbiBwZXJpbWV0ZXJcbiAgICB2YXIgX2VhcmN1dEZsYXR0ZW4gPSBmbGF0dGVuKGNvbnRvdXIpLFxuICAgICAgdmVydGljZXMgPSBfZWFyY3V0RmxhdHRlbi52ZXJ0aWNlcyxcbiAgICAgIF9lYXJjdXRGbGF0dGVuJGhvbGVzID0gX2VhcmN1dEZsYXR0ZW4uaG9sZXMsXG4gICAgICBob2xlcyA9IF9lYXJjdXRGbGF0dGVuJGhvbGVzID09PSB1bmRlZmluZWQgPyBbXSA6IF9lYXJjdXRGbGF0dGVuJGhvbGVzO1xuICAgIGluZGljZXMgPSBlYXJjdXQodmVydGljZXMsIGhvbGVzLCAyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgZGVsYXVuYXRvclxuICAgIHZhciBkZWxhdW5heSA9IERlbGF1bmF0b3IuZnJvbShwb2ludHMpO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgIHZhciBfaW5kaWNlczI7XG4gICAgICB2YXIgaW5kcyA9IFsyLCAxLCAwXS5tYXAoZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICByZXR1cm4gZGVsYXVuYXkudHJpYW5nbGVzW2kgKyBpZHhdO1xuICAgICAgfSk7IC8vIHJldmVyc2Ugd291bmQgdG8gaGF2ZSBzYW1lIG9yaWVudGF0aW9uIGFzIGVhcmN1dFxuICAgICAgdmFyIHRyaWFuZ2xlID0gaW5kcy5tYXAoZnVuY3Rpb24gKGluZGljZSkge1xuICAgICAgICByZXR1cm4gcG9pbnRzW2luZGljZV07XG4gICAgICB9KTtcblxuICAgICAgLy8gZXhjbHVkZSBlZGdlIHRyaWFuZ2xlcyBvdXRzaWRlIHBvbHlnb24gcGVyaW1ldGVyIG9yIHRocm91Z2ggaG9sZXNcbiAgICAgIGlmIChpbmRzLnNvbWUoZnVuY3Rpb24gKGluZCkge1xuICAgICAgICByZXR1cm4gaW5kIDwgZWRnZVBvaW50cy5sZW5ndGg7XG4gICAgICB9KSkge1xuICAgICAgICB2YXIgdHJpYW5nbGVDZW50cm9pZCA9IFswLCAxXS5tYXAoZnVuY3Rpb24gKGNvb3JkSWR4KSB7XG4gICAgICAgICAgcmV0dXJuIG1lYW4odHJpYW5nbGUsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gcFtjb29yZElkeF07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXBvaW50SW5zaWRlKHRyaWFuZ2xlQ2VudHJvaWQsIGJvdW5kYXJpZXNHZW9qc29uLCBjcm9zc2VzUG9sZU9yQW50aW1lcmlkaWFuKSkgcmV0dXJuIDE7IC8vIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICAoX2luZGljZXMyID0gaW5kaWNlcykucHVzaC5hcHBseShfaW5kaWNlczIsIF90b0NvbnN1bWFibGVBcnJheShpbmRzKSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVsYXVuYXkudHJpYW5nbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICBpZiAoX2xvb3AoaSkpIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNhbGMgdXZzXG4gIHZhciBsbmdVdlNjYWxlID0gc2NhbGVMaW5lYXIoZXh0ZW50KHBvaW50cywgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZFswXTtcbiAgfSksIFswLCAxXSk7XG4gIHZhciBsYXRVdlNjYWxlID0gc2NhbGVMaW5lYXIoZXh0ZW50KHBvaW50cywgZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfSksIFswLCAxXSk7XG4gIHZhciB1dnMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChfcmVmNikge1xuICAgIHZhciBfcmVmNyA9IF9zbGljZWRUb0FycmF5KF9yZWY2LCAyKSxcbiAgICAgIGxuZyA9IF9yZWY3WzBdLFxuICAgICAgbGF0ID0gX3JlZjdbMV07XG4gICAgcmV0dXJuIFtsbmdVdlNjYWxlKGxuZyksIGxhdFV2U2NhbGUobGF0KV07XG4gIH0pO1xuICB2YXIgdHJpYW5nbGVzID0ge1xuICAgIHBvaW50czogcG9pbnRzLFxuICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgdXZzOiB1dnNcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb250b3VyOiBjb250b3VyLFxuICAgIHRyaWFuZ2xlczogdHJpYW5nbGVzXG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbnRvdXJQb2ludHMocG9seWdvbiwgbWF4RGlzdGFuY2UpIHtcbiAgLy8gYWRkIGludGVycG9sYXRlZCBwb2ludHMgZm9yIHNlZ21lbnRzIHRoYXQgYXJlIGZ1cnRoZXIgYXBhcnQgdGhhbiB0aGUgbWF4IGRpc3RhbmNlXG4gIHJldHVybiBwb2x5Z29uLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgdmFyIHBudHMgPSBbXTtcbiAgICB2YXIgcHJldlBudDtcbiAgICBjb29yZHMuZm9yRWFjaChmdW5jdGlvbiAocG50KSB7XG4gICAgICBpZiAocHJldlBudCkge1xuICAgICAgICB2YXIgZGlzdCA9IGdlb0Rpc3RhbmNlKHBudCwgcHJldlBudCkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICBpZiAoZGlzdCA+IG1heERpc3RhbmNlKSB7XG4gICAgICAgICAgdmFyIGludGVycG9sID0gZ2VvSW50ZXJwb2xhdGUocHJldlBudCwgcG50KTtcbiAgICAgICAgICB2YXIgdFN0ZXAgPSAxIC8gTWF0aC5jZWlsKGRpc3QgLyBtYXhEaXN0YW5jZSk7XG4gICAgICAgICAgdmFyIHQgPSB0U3RlcDtcbiAgICAgICAgICB3aGlsZSAodCA8IDEpIHtcbiAgICAgICAgICAgIHBudHMucHVzaChpbnRlcnBvbCh0KSk7XG4gICAgICAgICAgICB0ICs9IHRTdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG50cy5wdXNoKHByZXZQbnQgPSBwbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiBwbnRzO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldElubmVyR2VvUG9pbnRzKHBvbHlnb24sIG1heERpc3RhbmNlKSB7XG4gIHZhciBib3VuZGFyaWVzR2VvanNvbiA9IHtcbiAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgY29vcmRpbmF0ZXM6IHBvbHlnb25cbiAgfTtcbiAgdmFyIF9nZW9Cb3VuZHMzID0gZ2VvQm91bmRzKGJvdW5kYXJpZXNHZW9qc29uKSxcbiAgICBfZ2VvQm91bmRzNCA9IF9zbGljZWRUb0FycmF5KF9nZW9Cb3VuZHMzLCAyKSxcbiAgICBfZ2VvQm91bmRzNCQgPSBfc2xpY2VkVG9BcnJheShfZ2VvQm91bmRzNFswXSwgMiksXG4gICAgbWluTG5nID0gX2dlb0JvdW5kczQkWzBdLFxuICAgIG1pbkxhdCA9IF9nZW9Cb3VuZHM0JFsxXSxcbiAgICBfZ2VvQm91bmRzNCQyID0gX3NsaWNlZFRvQXJyYXkoX2dlb0JvdW5kczRbMV0sIDIpLFxuICAgIG1heExuZyA9IF9nZW9Cb3VuZHM0JDJbMF0sXG4gICAgbWF4TGF0ID0gX2dlb0JvdW5kczQkMlsxXTtcblxuICAvLyBwb2x5Z29uIHNtYWxsZXIgdGhhbiBtYXhEaXN0YW5jZSAtPiBubyBpbm5lciBwb2ludHNcbiAgaWYgKE1hdGgubWluKE1hdGguYWJzKG1heExuZyAtIG1pbkxuZyksIE1hdGguYWJzKG1heExhdCAtIG1pbkxhdCkpIDwgbWF4RGlzdGFuY2UpIHJldHVybiBbXTtcbiAgdmFyIGNyb3NzZXNQb2xlT3JBbnRpbWVyaWRpYW4gPSBtaW5MbmcgPiBtYXhMbmcgfHwgbWF4TGF0ID49IDg5IHx8IG1pbkxhdCA8PSAtODk7XG4gIHJldHVybiBnZXRHZW9TcGlyYWxHcmlkKG1heERpc3RhbmNlLCB7XG4gICAgbWluTG5nOiBtaW5MbmcsXG4gICAgbWF4TG5nOiBtYXhMbmcsXG4gICAgbWluTGF0OiBtaW5MYXQsXG4gICAgbWF4TGF0OiBtYXhMYXRcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uIChwbnQpIHtcbiAgICByZXR1cm4gcG9pbnRJbnNpZGUocG50LCBib3VuZGFyaWVzR2VvanNvbiwgY3Jvc3Nlc1BvbGVPckFudGltZXJpZGlhbik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0R2VvU3BpcmFsR3JpZChkaXN0YW5jZUJldHdlZW5Qb2ludHMpIHtcbiAgdmFyIF9yZWY4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICBtaW5MbmcgPSBfcmVmOC5taW5MbmcsXG4gICAgbWF4TG5nID0gX3JlZjgubWF4TG5nLFxuICAgIG1pbkxhdCA9IF9yZWY4Lm1pbkxhdCxcbiAgICBtYXhMYXQgPSBfcmVmOC5tYXhMYXQ7XG4gIHZhciBudW1Qb2ludHMgPSBNYXRoLnJvdW5kKE1hdGgucG93KDM2MCAvIGRpc3RhbmNlQmV0d2VlblBvaW50cywgMikgLyBNYXRoLlBJKTtcblxuICAvLyBodHRwczovL29ic2VydmFibGVocS5jb20vQG1ib3N0b2NrL3NwaGVyaWNhbC1maWJvbmFjY2ktbGF0dGljZVxuICB2YXIgcGhpID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjsgLy8gZ29sZGVuIHJhdGlvXG5cbiAgdmFyIGdldFBudExuZyA9IGZ1bmN0aW9uIGdldFBudExuZyhpZHgpIHtcbiAgICByZXR1cm4gaWR4IC8gcGhpICogMzYwICUgMzYwIC0gMTgwO1xuICB9O1xuICB2YXIgZ2V0UG50TGF0ID0gZnVuY3Rpb24gZ2V0UG50TGF0KGlkeCkge1xuICAgIHJldHVybiBNYXRoLmFjb3MoMiAqIGlkeCAvIG51bVBvaW50cyAtIDEpIC8gTWF0aC5QSSAqIDE4MCAtIDkwO1xuICB9O1xuICB2YXIgZ2V0UG50SWR4ID0gZnVuY3Rpb24gZ2V0UG50SWR4KGxhdCkge1xuICAgIHJldHVybiBudW1Qb2ludHMgKiAoTWF0aC5jb3MoKGxhdCArIDkwKSAqIE1hdGguUEkgLyAxODApICsgMSkgLyAyO1xuICB9O1xuICB2YXIgcG50SWR4UmFuZ2UgPSBbbWF4TGF0ICE9PSB1bmRlZmluZWQgPyBNYXRoLmNlaWwoZ2V0UG50SWR4KG1heExhdCkpIDogMCwgbWluTGF0ICE9PSB1bmRlZmluZWQgPyBNYXRoLmZsb29yKGdldFBudElkeChtaW5MYXQpKSA6IG51bVBvaW50cyAtIDFdO1xuICB2YXIgaXNMbmdJblJhbmdlID0gbWluTG5nID09PSB1bmRlZmluZWQgJiYgbWF4TG5nID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gOiBtaW5MbmcgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChsbmcpIHtcbiAgICByZXR1cm4gbG5nIDw9IG1heExuZztcbiAgfSA6IG1heExuZyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24gKGxuZykge1xuICAgIHJldHVybiBsbmcgPj0gbWluTG5nO1xuICB9IDogbWF4TG5nID49IG1pbkxuZyA/IGZ1bmN0aW9uIChsbmcpIHtcbiAgICByZXR1cm4gbG5nID49IG1pbkxuZyAmJiBsbmcgPD0gbWF4TG5nO1xuICB9IDogZnVuY3Rpb24gKGxuZykge1xuICAgIHJldHVybiBsbmcgPj0gbWluTG5nIHx8IGxuZyA8PSBtYXhMbmc7XG4gIH07IC8vIGZvciByYW5nZXMgdGhhdCBjcm9zcyB0aGUgYW50aS1tZXJpZGlhblxuXG4gIHZhciBwbnRzID0gW107XG4gIGZvciAodmFyIGkgPSBwbnRJZHhSYW5nZVswXTsgaSA8PSBwbnRJZHhSYW5nZVsxXTsgaSsrKSB7XG4gICAgdmFyIGxuZyA9IGdldFBudExuZyhpKTtcbiAgICBpc0xuZ0luUmFuZ2UobG5nKSAmJiBwbnRzLnB1c2goW2xuZywgZ2V0UG50TGF0KGkpXSk7XG4gIH1cbiAgcmV0dXJuIHBudHM7XG59XG5mdW5jdGlvbiBwb2ludEluc2lkZShwbnQsIHBvbHlnb24pIHtcbiAgdmFyIGNyb3NzZXNQb2xlT3JBbnRpbWVyaWRpYW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAvLyB0dXJmIG1ldGhvZCBpcyBtb3JlIHBlcmZvcm1pbmcgYnV0IG1hbGZ1bmN0aW9ucyBpZiBwb2x5Z29uIGluY2x1ZGVzIGEgcG9sZSAobGF0ID0gOTAgfCAtOTApIG9yIGNyb3NzZXMgdGhlIGFudGltZXJpZGlhbiAobG5nID0gMTgwIHwgLTE4MClcbiAgcmV0dXJuIGNyb3NzZXNQb2xlT3JBbnRpbWVyaWRpYW4gPyBnZW9Db250YWlucyhwb2x5Z29uLCBwbnQpIDogdHVyZlBvaW50SW5Qb2x5Z29uKHBudCwgcG9seWdvbik7XG59XG5cbnZhciBUSFJFRSA9IHdpbmRvdy5USFJFRSA/IHdpbmRvdy5USFJFRSAvLyBQcmVmZXIgY29uc3VtcHRpb24gZnJvbSBnbG9iYWwgVEhSRUUsIGlmIGV4aXN0c1xuOiB7XG4gIEJ1ZmZlckdlb21ldHJ5OiBCdWZmZXJHZW9tZXRyeSxcbiAgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZTogRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZVxufTtcblxuLy8gc3VwcG9ydCBib3RoIG1vZGVzIGZvciBiYWNrd2FyZHMgdGhyZWVqcyBjb21wYXRpYmlsaXR5XG52YXIgc2V0QXR0cmlidXRlRm4gPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKS5zZXRBdHRyaWJ1dGUgPyAnc2V0QXR0cmlidXRlJyA6ICdhZGRBdHRyaWJ1dGUnO1xudmFyIENvbmljUG9seWdvbkdlb21ldHJ5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVEhSRUUkQnVmZmVyR2VvbWV0cnkpIHtcbiAgZnVuY3Rpb24gQ29uaWNQb2x5Z29uR2VvbWV0cnkocG9seWdvbkdlb0pzb24sIGJvdHRvbUhlaWdodCwgdG9wSGVpZ2h0LCBjbG9zZWRCb3R0b20sIGNsb3NlZFRvcCwgaW5jbHVkZVNpZGVzLCBjdXJ2YXR1cmVSZXNvbHV0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb25pY1BvbHlnb25HZW9tZXRyeSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENvbmljUG9seWdvbkdlb21ldHJ5KTtcbiAgICBfdGhpcy50eXBlID0gJ0NvbmljUG9seWdvbkdlb21ldHJ5JztcbiAgICBfdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgICAgcG9seWdvbkdlb0pzb246IHBvbHlnb25HZW9Kc29uLFxuICAgICAgYm90dG9tSGVpZ2h0OiBib3R0b21IZWlnaHQsXG4gICAgICB0b3BIZWlnaHQ6IHRvcEhlaWdodCxcbiAgICAgIGNsb3NlZEJvdHRvbTogY2xvc2VkQm90dG9tLFxuICAgICAgY2xvc2VkVG9wOiBjbG9zZWRUb3AsXG4gICAgICBpbmNsdWRlU2lkZXM6IGluY2x1ZGVTaWRlcyxcbiAgICAgIGN1cnZhdHVyZVJlc29sdXRpb246IGN1cnZhdHVyZVJlc29sdXRpb25cbiAgICB9O1xuXG4gICAgLy8gZGVmYXVsdHNcbiAgICBib3R0b21IZWlnaHQgPSBib3R0b21IZWlnaHQgfHwgMDtcbiAgICB0b3BIZWlnaHQgPSB0b3BIZWlnaHQgfHwgMTtcbiAgICBjbG9zZWRCb3R0b20gPSBjbG9zZWRCb3R0b20gIT09IHVuZGVmaW5lZCA/IGNsb3NlZEJvdHRvbSA6IHRydWU7XG4gICAgY2xvc2VkVG9wID0gY2xvc2VkVG9wICE9PSB1bmRlZmluZWQgPyBjbG9zZWRUb3AgOiB0cnVlO1xuICAgIGluY2x1ZGVTaWRlcyA9IGluY2x1ZGVTaWRlcyAhPT0gdW5kZWZpbmVkID8gaW5jbHVkZVNpZGVzIDogdHJ1ZTtcbiAgICBjdXJ2YXR1cmVSZXNvbHV0aW9uID0gY3VydmF0dXJlUmVzb2x1dGlvbiB8fCA1OyAvLyBpbiBhbmd1bGFyIGRlZ3JlZXNcblxuICAgIC8vIHByZS1jYWxjdWxhdGUgY29udG91ciwgdHJpYW5ndWxhdGlvbiBhbmQgVVYgbWFwc1xuICAgIHZhciBfZ2VvUG9seWdvblRyaWFuZ3VsYXQgPSBnZW9Qb2x5Z29uVHJpYW5ndWxhdGUocG9seWdvbkdlb0pzb24sIHtcbiAgICAgICAgcmVzb2x1dGlvbjogY3VydmF0dXJlUmVzb2x1dGlvblxuICAgICAgfSksXG4gICAgICBjb250b3VyID0gX2dlb1BvbHlnb25Ucmlhbmd1bGF0LmNvbnRvdXIsXG4gICAgICB0cmlhbmdsZXMgPSBfZ2VvUG9seWdvblRyaWFuZ3VsYXQudHJpYW5nbGVzO1xuICAgIHZhciBmbGF0VXZzID0gbWVyZ2UodHJpYW5nbGVzLnV2cyk7XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgdmFyIHV2cyA9IFtdO1xuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgdmFyIGdyb3VwQ250ID0gMDsgLy8gYWRkIGdyb3VwcyB0byBhcHBseSBkaWZmZXJlbnQgbWF0ZXJpYWxzIHRvIHRvcnNvIC8gY2Fwc1xuXG4gICAgdmFyIGFkZEdyb3VwID0gZnVuY3Rpb24gYWRkR3JvdXAoZ3JvdXBEYXRhKSB7XG4gICAgICB2YXIgcHJldlZlcnRDbnQgPSBNYXRoLnJvdW5kKHZlcnRpY2VzLmxlbmd0aCAvIDMpO1xuICAgICAgdmFyIHByZXZJbmRDbnQgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KGdyb3VwRGF0YS52ZXJ0aWNlcyk7XG4gICAgICB1dnMgPSB1dnMuY29uY2F0KGdyb3VwRGF0YS51dnMpO1xuICAgICAgaW5kaWNlcyA9IGluZGljZXMuY29uY2F0KCFwcmV2VmVydENudCA/IGdyb3VwRGF0YS5pbmRpY2VzIDogZ3JvdXBEYXRhLmluZGljZXMubWFwKGZ1bmN0aW9uIChpbmQpIHtcbiAgICAgICAgcmV0dXJuIGluZCArIHByZXZWZXJ0Q250O1xuICAgICAgfSkpO1xuICAgICAgX3RoaXMuYWRkR3JvdXAocHJldkluZENudCwgaW5kaWNlcy5sZW5ndGggLSBwcmV2SW5kQ250LCBncm91cENudCsrKTtcbiAgICB9O1xuICAgIGluY2x1ZGVTaWRlcyAmJiBhZGRHcm91cChnZW5lcmF0ZVRvcnNvKCkpO1xuICAgIGNsb3NlZEJvdHRvbSAmJiBhZGRHcm91cChnZW5lcmF0ZUNhcChib3R0b21IZWlnaHQsIGZhbHNlKSk7XG4gICAgY2xvc2VkVG9wICYmIGFkZEdyb3VwKGdlbmVyYXRlQ2FwKHRvcEhlaWdodCwgdHJ1ZSkpO1xuXG4gICAgLy8gYnVpbGQgZ2VvbWV0cnlcbiAgICBfdGhpcy5zZXRJbmRleChpbmRpY2VzKTtcbiAgICBfdGhpc1tzZXRBdHRyaWJ1dGVGbl0oJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodmVydGljZXMsIDMpKTtcbiAgICBfdGhpc1tzZXRBdHRyaWJ1dGVGbl0oJ3V2JywgbmV3IFRIUkVFLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUodXZzLCAyKSk7XG5cbiAgICAvLyBhdXRvLWNhbGN1bGF0ZSBub3JtYWxzXG4gICAgX3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVZlcnRpY2VzKHBvbHlnb24sIGFsdGl0dWRlKSB7XG4gICAgICB2YXIgYWx0Rm4gPSB0eXBlb2YgYWx0aXR1ZGUgPT09ICdmdW5jdGlvbicgPyBhbHRpdHVkZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFsdGl0dWRlO1xuICAgICAgfTtcbiAgICAgIHZhciBjb29yZHMzZCA9IHBvbHlnb24ubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIGNvb3Jkcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICAgICAgICAgIGxuZyA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgbGF0ID0gX3JlZjJbMV07XG4gICAgICAgICAgcmV0dXJuIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZywgYWx0Rm4obG5nLCBsYXQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIHJldHVybnMgeyB2ZXJ0aWNlcywgaG9sZXMsIGNvb3JkaW5hdGVzIH0uIEVhY2ggcG9pbnQgZ2VuZXJhdGVzIDMgdmVydGljZSBpdGVtcyAoeCx5LHopLlxuICAgICAgcmV0dXJuIGZsYXR0ZW4oY29vcmRzM2QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xuICAgICAgdmFyIF9nZW5lcmF0ZVZlcnRpY2VzID0gZ2VuZXJhdGVWZXJ0aWNlcyhjb250b3VyLCBib3R0b21IZWlnaHQpLFxuICAgICAgICBib3R0b21WZXJ0cyA9IF9nZW5lcmF0ZVZlcnRpY2VzLnZlcnRpY2VzLFxuICAgICAgICBob2xlcyA9IF9nZW5lcmF0ZVZlcnRpY2VzLmhvbGVzO1xuICAgICAgdmFyIF9nZW5lcmF0ZVZlcnRpY2VzMiA9IGdlbmVyYXRlVmVydGljZXMoY29udG91ciwgdG9wSGVpZ2h0KSxcbiAgICAgICAgdG9wVmVydHMgPSBfZ2VuZXJhdGVWZXJ0aWNlczIudmVydGljZXM7XG4gICAgICB2YXIgdmVydGljZXMgPSBtZXJnZShbdG9wVmVydHMsIGJvdHRvbVZlcnRzXSk7XG4gICAgICB2YXIgbnVtUG9pbnRzID0gTWF0aC5yb3VuZCh0b3BWZXJ0cy5sZW5ndGggLyAzKTtcbiAgICAgIHZhciBob2xlc0lkeCA9IG5ldyBTZXQoaG9sZXMpO1xuICAgICAgdmFyIGxhc3RIb2xlSWR4ID0gMDtcbiAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICBmb3IgKHZhciB2MElkeCA9IDA7IHYwSWR4IDwgbnVtUG9pbnRzOyB2MElkeCsrKSB7XG4gICAgICAgIHZhciB2MUlkeCA9IHYwSWR4ICsgMTsgLy8gbmV4dCBwb2ludFxuICAgICAgICBpZiAodjFJZHggPT09IG51bVBvaW50cykge1xuICAgICAgICAgIHYxSWR4ID0gbGFzdEhvbGVJZHg7IC8vIGNsb3NlIGZpbmFsIGxvb3BcbiAgICAgICAgfSBlbHNlIGlmIChob2xlc0lkeC5oYXModjFJZHgpKSB7XG4gICAgICAgICAgdmFyIGhvbGVJZHggPSB2MUlkeDtcbiAgICAgICAgICB2MUlkeCA9IGxhc3RIb2xlSWR4OyAvLyBjbG9zZSBob2xlIGxvb3BcbiAgICAgICAgICBsYXN0SG9sZUlkeCA9IGhvbGVJZHg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFYWNoIHBhaXIgb2YgY29vcmRzIGdlbmVyYXRlcyB0d28gdHJpYW5nbGVzIChmYWNlcylcbiAgICAgICAgaW5kaWNlcy5wdXNoKHYwSWR4LCB2MElkeCArIG51bVBvaW50cywgdjFJZHggKyBudW1Qb2ludHMpO1xuICAgICAgICBpbmRpY2VzLnB1c2godjFJZHggKyBudW1Qb2ludHMsIHYxSWR4LCB2MElkeCk7XG4gICAgICB9XG4gICAgICB2YXIgdXZzID0gW107IC8vIHdyYXAgdGV4dHVyZSBhcm91bmQgcGVyaW1ldGVyICh1KSwgd2l0aCB2PTEgb24gdG9wXG4gICAgICBmb3IgKHZhciB2ID0gMTsgdiA+PSAwOyB2LS0pIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpICs9IDEpIHV2cy5wdXNoKGkgLyAobnVtUG9pbnRzIC0gMSksIHYpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kaWNlczogaW5kaWNlcyxcbiAgICAgICAgdmVydGljZXM6IHZlcnRpY2VzLFxuICAgICAgICB1dnM6IHV2c1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYXAocmFkaXVzKSB7XG4gICAgICB2YXIgaXNUb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBuZWVkIHRvIHJldmVyc2Utd2luZCB0aGUgYm90dG9tIHRyaWFuZ2xlcyB0byBtYWtlIHRoZW0gZmFjZSBvdXR3YXJkc1xuICAgICAgICBpbmRpY2VzOiBpc1RvcCA/IHRyaWFuZ2xlcy5pbmRpY2VzIDogdHJpYW5nbGVzLmluZGljZXMuc2xpY2UoKS5yZXZlcnNlKCksXG4gICAgICAgIHZlcnRpY2VzOiBnZW5lcmF0ZVZlcnRpY2VzKFt0cmlhbmdsZXMucG9pbnRzXSwgcmFkaXVzKS52ZXJ0aWNlcyxcbiAgICAgICAgdXZzOiBmbGF0VXZzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKENvbmljUG9seWdvbkdlb21ldHJ5LCBfVEhSRUUkQnVmZmVyR2VvbWV0cnkpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbmljUG9seWdvbkdlb21ldHJ5KTtcbn0oVEhSRUUuQnVmZmVyR2VvbWV0cnkpOyAvL1xuZnVuY3Rpb24gcG9sYXIyQ2FydGVzaWFuKGxhdCwgbG5nKSB7XG4gIHZhciByID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICB2YXIgcGhpID0gKDkwIC0gbGF0KSAqIE1hdGguUEkgLyAxODA7XG4gIHZhciB0aGV0YSA9ICg5MCAtIGxuZykgKiBNYXRoLlBJIC8gMTgwO1xuICByZXR1cm4gW3IgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpLFxuICAvLyB4XG4gIHIgKiBNYXRoLmNvcyhwaGkpLFxuICAvLyB5XG4gIHIgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpIC8vIHpcbiAgXTtcbn1cblxuZXhwb3J0IHsgQ29uaWNQb2x5Z29uR2VvbWV0cnkgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs\n");

/***/ })

};
;