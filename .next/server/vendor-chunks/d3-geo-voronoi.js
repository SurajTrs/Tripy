"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/d3-geo-voronoi";
exports.ids = ["vendor-chunks/d3-geo-voronoi"];
exports.modules = {

/***/ "(ssr)/./node_modules/d3-geo-voronoi/src/cartesian.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-geo-voronoi/src/cartesian.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cartesian: () => (/* binding */ cartesian),\n/* harmony export */   cartesianAdd: () => (/* binding */ cartesianAdd),\n/* harmony export */   cartesianAddInPlace: () => (/* binding */ cartesianAddInPlace),\n/* harmony export */   cartesianCross: () => (/* binding */ cartesianCross),\n/* harmony export */   cartesianDot: () => (/* binding */ cartesianDot),\n/* harmony export */   cartesianNormalize: () => (/* binding */ cartesianNormalize),\n/* harmony export */   cartesianNormalizeInPlace: () => (/* binding */ cartesianNormalizeInPlace),\n/* harmony export */   cartesianScale: () => (/* binding */ cartesianScale),\n/* harmony export */   spherical: () => (/* binding */ spherical)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/d3-geo-voronoi/src/math.js\");\n\n\nfunction spherical(cartesian) {\n  return [(0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(cartesian[2])];\n}\n\nfunction cartesian(spherical) {\n  const lambda = spherical[0],\n    phi = spherical[1],\n    cosPhi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);\n  return [cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosPhi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];\n}\n\nfunction cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nfunction cartesianCross(a, b) {\n  return [\n    a[1] * b[2] - a[2] * b[1],\n    a[2] * b[0] - a[0] * b[2],\n    a[0] * b[1] - a[1] * b[0],\n  ];\n}\n\n// TODO return a\nfunction cartesianAddInPlace(a, b) {\n  (a[0] += b[0]), (a[1] += b[1]), (a[2] += b[2]);\n}\n\nfunction cartesianAdd(a, b) {\n  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];\n}\n\nfunction cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nfunction cartesianNormalizeInPlace(d) {\n  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  (d[0] /= l), (d[1] /= l), (d[2] /= l);\n}\n\nfunction cartesianNormalize(d) {\n  var l = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  return [d[0] / l, d[1] / l, d[2] / l];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXZvcm9ub2kvc3JjL2NhcnRlc2lhbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXdEOztBQUVqRDtBQUNQLFVBQVUsK0NBQUssOEJBQThCLDhDQUFJO0FBQ2pEOztBQUVPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsNkNBQUc7QUFDaEIsbUJBQW1CLDZDQUFHLG1CQUFtQiw2Q0FBRyxVQUFVLDZDQUFHO0FBQ3pEOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ087QUFDUCxVQUFVLDhDQUFJO0FBQ2Q7QUFDQTs7QUFFTztBQUNQLFVBQVUsOENBQUk7QUFDZDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc3VyYWpyYXdhdC9Eb3dubG9hZHMvVHJpcHkvbm9kZV9tb2R1bGVzL2QzLWdlby12b3Jvbm9pL3NyYy9jYXJ0ZXNpYW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNpbiwgYXRhbjIsIGNvcywgc2luLCBzcXJ0IH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICByZXR1cm4gW2F0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSwgYXNpbihjYXJ0ZXNpYW5bMl0pXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgY29uc3QgbGFtYmRhID0gc3BoZXJpY2FsWzBdLFxuICAgIHBoaSA9IHNwaGVyaWNhbFsxXSxcbiAgICBjb3NQaGkgPSBjb3MocGhpKTtcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkRvdChhLCBiKSB7XG4gIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5Dcm9zcyhhLCBiKSB7XG4gIHJldHVybiBbXG4gICAgYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSxcbiAgICBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLFxuICAgIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF0sXG4gIF07XG59XG5cbi8vIFRPRE8gcmV0dXJuIGFcbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgKGFbMF0gKz0gYlswXSksIChhWzFdICs9IGJbMV0pLCAoYVsyXSArPSBiWzJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbkFkZChhLCBiKSB7XG4gIHJldHVybiBbYVswXSArIGJbMF0sIGFbMV0gKyBiWzFdLCBhWzJdICsgYlsyXV07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXJ0ZXNpYW5TY2FsZSh2ZWN0b3IsIGspIHtcbiAgcmV0dXJuIFt2ZWN0b3JbMF0gKiBrLCB2ZWN0b3JbMV0gKiBrLCB2ZWN0b3JbMl0gKiBrXTtcbn1cblxuLy8gVE9ETyByZXR1cm4gZFxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgKGRbMF0gLz0gbCksIChkWzFdIC89IGwpLCAoZFsyXSAvPSBsKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZShkKSB7XG4gIHZhciBsID0gc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICByZXR1cm4gW2RbMF0gLyBsLCBkWzFdIC8gbCwgZFsyXSAvIGxdO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-geo-voronoi/src/cartesian.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/d3-geo-voronoi/src/delaunay.js":
/*!*****************************************************!*\
  !*** ./node_modules/d3-geo-voronoi/src/delaunay.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   excess: () => (/* binding */ excess),\n/* harmony export */   geoDelaunay: () => (/* binding */ geoDelaunay)\n/* harmony export */ });\n/* harmony import */ var d3_delaunay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-delaunay */ \"(ssr)/./node_modules/d3-delaunay/src/delaunay.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/rotation.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/projection/stereographic.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/extent.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/d3-geo-voronoi/src/math.js\");\n/* harmony import */ var _cartesian_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cartesian.js */ \"(ssr)/./node_modules/d3-geo-voronoi/src/cartesian.js\");\n\n\n\n\n\n\n// Converts 3D Cartesian to spherical coordinates (degrees).\nfunction spherical(cartesian) {\n  return [\n    (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.atan2)(cartesian[1], cartesian[0]) * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees,\n    (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(-1, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(1, cartesian[2]))) * _math_js__WEBPACK_IMPORTED_MODULE_0__.degrees,\n  ];\n}\n\n// Converts spherical coordinates (degrees) to 3D Cartesian.\nfunction cartesian(coordinates) {\n  const lambda = coordinates[0] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,\n    phi = coordinates[1] * _math_js__WEBPACK_IMPORTED_MODULE_0__.radians,\n    cosphi = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi);\n  return [cosphi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(lambda), cosphi * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(lambda), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];\n}\n\n// Spherical excess of a triangle (in spherical coordinates)\nfunction excess(triangle) {\n  triangle = triangle.map((p) => cartesian(p));\n  return (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianDot)(triangle[0], (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(triangle[2], triangle[1]));\n}\n\nfunction geoDelaunay(points) {\n  const delaunay = geo_delaunay_from(points),\n    triangles = geo_triangles(delaunay),\n    edges = geo_edges(triangles, points),\n    neighbors = geo_neighbors(triangles, points.length),\n    find = geo_find(neighbors, points),\n    // Voronoi ; could take a center function as an argument\n    circumcenters = geo_circumcenters(triangles, points),\n    { polygons, centers } = geo_polygons(circumcenters, triangles, points),\n    mesh = geo_mesh(polygons),\n    hull = geo_hull(triangles, points),\n    // Urquhart ; returns a function that takes a distance array as argument.\n    urquhart = geo_urquhart(edges, triangles);\n  return {\n    delaunay,\n    edges,\n    triangles,\n    centers,\n    neighbors,\n    polygons,\n    mesh,\n    hull,\n    urquhart,\n    find,\n  };\n}\n\nfunction geo_find(neighbors, points) {\n  function distance2(a, b) {\n    let x = a[0] - b[0],\n      y = a[1] - b[1],\n      z = a[2] - b[2];\n    return x * x + y * y + z * z;\n  }\n\n  return function find(x, y, next) {\n    if (next === undefined) next = 0;\n    let cell,\n      dist,\n      found = next;\n    const xyz = cartesian([x, y]);\n    do {\n      cell = next;\n      next = null;\n      dist = distance2(xyz, cartesian(points[cell]));\n      neighbors[cell].forEach((i) => {\n        let ndist = distance2(xyz, cartesian(points[i]));\n        if (ndist < dist) {\n          dist = ndist;\n          next = i;\n          found = i;\n          return;\n        }\n      });\n    } while (next !== null);\n\n    return found;\n  };\n}\n\nfunction geo_delaunay_from(points) {\n  if (points.length < 2) return {};\n\n  // find a valid point to send to infinity\n  let pivot = 0;\n  while (isNaN(points[pivot][0] + points[pivot][1]) && pivot++ < points.length);\n\n  const r = (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(points[pivot]),\n    projection = (0,d3_geo__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()\n      .translate([0, 0])\n      .scale(1)\n      .rotate(r.invert([180, 0]));\n  points = points.map(projection);\n\n  const zeros = [];\n  let max2 = 1;\n  for (let i = 0, n = points.length; i < n; i++) {\n    let m = points[i][0] ** 2 + points[i][1] ** 2;\n    if (!isFinite(m) || m > 1e32) zeros.push(i);\n    else if (m > max2) max2 = m;\n  }\n\n  const FAR = 1e6 * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt)(max2);\n\n  zeros.forEach((i) => (points[i] = [FAR, 0]));\n\n  // Add infinite horizon points\n  points.push([0, FAR]);\n  points.push([-FAR, 0]);\n  points.push([0, -FAR]);\n\n  const delaunay = d3_delaunay__WEBPACK_IMPORTED_MODULE_4__[\"default\"].from(points);\n\n  delaunay.projection = projection;\n\n  // clean up the triangulation\n  const { triangles, halfedges, inedges } = delaunay;\n  const degenerate = [];\n  for (let i = 0, l = halfedges.length; i < l; i++) {\n    if (halfedges[i] < 0) {\n      const j = i % 3 == 2 ? i - 2 : i + 1;\n      const k = i % 3 == 0 ? i + 2 : i - 1;\n      const a = halfedges[j];\n      const b = halfedges[k];\n      halfedges[a] = b;\n      halfedges[b] = a;\n      halfedges[j] = halfedges[k] = -1;\n      triangles[i] = triangles[j] = triangles[k] = pivot;\n      inedges[triangles[a]] = a % 3 == 0 ? a + 2 : a - 1;\n      inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;\n      degenerate.push(Math.min(i, j, k));\n      i += 2 - (i % 3);\n    } else if (triangles[i] > points.length - 3 - 1) {\n      triangles[i] = pivot;\n    }\n  }\n\n  // there should always be 4 degenerate triangles\n  // console.warn(degenerate);\n  return delaunay;\n}\n\nfunction geo_edges(triangles, points) {\n  const _index = new Set();\n  if (points.length === 2) return [[0, 1]];\n  triangles.forEach((tri) => {\n    if (tri[0] === tri[1]) return;\n    if (excess(tri.map((i) => points[i])) < 0) return;\n    for (let i = 0, j; i < 3; i++) {\n      j = (i + 1) % 3;\n      _index.add((0,d3_array__WEBPACK_IMPORTED_MODULE_5__[\"default\"])([tri[i], tri[j]]).join(\"-\"));\n    }\n  });\n  return Array.from(_index, (d) => d.split(\"-\").map(Number));\n}\n\nfunction geo_triangles(delaunay) {\n  const { triangles } = delaunay;\n  if (!triangles) return [];\n\n  const geo_triangles = [];\n  for (let i = 0, n = triangles.length / 3; i < n; i++) {\n    const a = triangles[3 * i],\n      b = triangles[3 * i + 1],\n      c = triangles[3 * i + 2];\n    if (a !== b && b !== c) {\n      geo_triangles.push([a, c, b]);\n    }\n  }\n  return geo_triangles;\n}\n\nfunction geo_circumcenters(triangles, points) {\n  // if (!use_centroids) {\n  return triangles.map((tri) => {\n    const c = tri.map((i) => points[i]).map(cartesian),\n      V = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianAdd)(\n        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianAdd)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(c[1], c[0]), (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(c[2], c[1])),\n        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(c[0], c[2])\n      );\n    return spherical((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalize)(V));\n  });\n  /*} else {\n    return triangles.map(tri => {\n      return d3.geoCentroid({\n        type: \"MultiPoint\",\n        coordinates: tri.map(i => points[i])\n      });\n    });\n  }*/\n}\n\nfunction geo_neighbors(triangles, npoints) {\n  const neighbors = [];\n  triangles.forEach((tri) => {\n    for (let j = 0; j < 3; j++) {\n      const a = tri[j],\n        b = tri[(j + 1) % 3];\n      neighbors[a] = neighbors[a] || [];\n      neighbors[a].push(b);\n    }\n  });\n\n  // degenerate cases\n  if (triangles.length === 0) {\n    if (npoints === 2) (neighbors[0] = [1]), (neighbors[1] = [0]);\n    else if (npoints === 1) neighbors[0] = [];\n  }\n\n  return neighbors;\n}\n\nfunction geo_polygons(circumcenters, triangles, points) {\n  const polygons = [];\n\n  const centers = circumcenters.slice();\n\n  if (triangles.length === 0) {\n    if (points.length < 2) return { polygons, centers };\n    if (points.length === 2) {\n      // two hemispheres\n      const a = cartesian(points[0]),\n        b = cartesian(points[1]),\n        m = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalize)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianAdd)(a, b)),\n        d = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalize)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(a, b)),\n        c = (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(m, d);\n      const poly = [\n        m,\n        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(m, c),\n        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(m, c), c),\n        (0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(m, c), c), c),\n      ]\n        .map(spherical)\n        .map(supplement);\n      return (\n        polygons.push(poly),\n        polygons.push(poly.slice().reverse()),\n        { polygons, centers }\n      );\n    }\n  }\n\n  triangles.forEach((tri, t) => {\n    for (let j = 0; j < 3; j++) {\n      const a = tri[j],\n        b = tri[(j + 1) % 3],\n        c = tri[(j + 2) % 3];\n      polygons[a] = polygons[a] || [];\n      polygons[a].push([b, c, t, [a, b, c]]);\n    }\n  });\n\n  // reorder each polygon\n  const reordered = polygons.map((poly) => {\n    const p = [poly[0][2]]; // t\n    let k = poly[0][1]; // k = c\n    for (let i = 1; i < poly.length; i++) {\n      // look for b = k\n      for (let j = 0; j < poly.length; j++) {\n        if (poly[j][0] == k) {\n          k = poly[j][1];\n          p.push(poly[j][2]);\n          break;\n        }\n      }\n    }\n\n    if (p.length > 2) {\n      return p;\n    } else if (p.length == 2) {\n      const R0 = o_midpoint(\n          points[poly[0][3][0]],\n          points[poly[0][3][1]],\n          centers[p[0]]\n        ),\n        R1 = o_midpoint(\n          points[poly[0][3][2]],\n          points[poly[0][3][0]],\n          centers[p[0]]\n        );\n      const i0 = supplement(R0),\n        i1 = supplement(R1);\n      return [p[0], i1, p[1], i0];\n    }\n  });\n\n  function supplement(point) {\n    let f = -1;\n    centers.slice(triangles.length, Infinity).forEach((p, i) => {\n      if (p[0] === point[0] && p[1] === point[1]) f = i + triangles.length;\n    });\n    if (f < 0) (f = centers.length), centers.push(point);\n    return f;\n  }\n\n  return { polygons: reordered, centers };\n}\n\nfunction o_midpoint(a, b, c) {\n  a = cartesian(a);\n  b = cartesian(b);\n  c = cartesian(c);\n  const s = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sign)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianDot)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianCross)(b, a), c));\n  return spherical((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianNormalize)((0,_cartesian_js__WEBPACK_IMPORTED_MODULE_1__.cartesianAdd)(a, b)).map((d) => s * d));\n}\n\nfunction geo_mesh(polygons) {\n  const mesh = [];\n  polygons.forEach((poly) => {\n    if (!poly) return;\n    let p = poly[poly.length - 1];\n    for (let q of poly) {\n      if (q > p) mesh.push([p, q]);\n      p = q;\n    }\n  });\n  return mesh;\n}\n\nfunction geo_urquhart(edges, triangles) {\n  return function (distances) {\n    const _lengths = new Map(),\n      _urquhart = new Map();\n    edges.forEach((edge, i) => {\n      const u = edge.join(\"-\");\n      _lengths.set(u, distances[i]);\n      _urquhart.set(u, true);\n    });\n\n    triangles.forEach((tri) => {\n      let l = 0,\n        remove = -1;\n      for (let j = 0; j < 3; j++) {\n        let u = (0,d3_array__WEBPACK_IMPORTED_MODULE_5__[\"default\"])([tri[j], tri[(j + 1) % 3]]).join(\"-\");\n        if (_lengths.get(u) > l) {\n          l = _lengths.get(u);\n          remove = u;\n        }\n      }\n      _urquhart.set(remove, false);\n    });\n\n    return edges.map((edge) => _urquhart.get(edge.join(\"-\")));\n  };\n}\n\nfunction geo_hull(triangles, points) {\n  const _hull = new Set(),\n    hull = [];\n  triangles.map((tri) => {\n    if (excess(tri.map((i) => points[i > points.length ? 0 : i])) > 1e-12)\n      return;\n    for (let i = 0; i < 3; i++) {\n      let e = [tri[i], tri[(i + 1) % 3]],\n        code = `${e[0]}-${e[1]}`;\n      if (_hull.has(code)) _hull.delete(code);\n      else _hull.add(`${e[1]}-${e[0]}`);\n    }\n  });\n\n  const _index = new Map();\n  let start;\n  _hull.forEach((e) => {\n    e = e.split(\"-\").map(Number);\n    _index.set(e[0], e[1]);\n    start = e[0];\n  });\n\n  if (start === undefined) return hull;\n\n  let next = start;\n  do {\n    hull.push(next);\n    let n = _index.get(next);\n    _index.set(next, -1);\n    next = n;\n  } while (next > -1 && next !== start);\n\n  return hull;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXZvcm9ub2kvc3JjL2RlbGF1bmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ2dCO0FBQ3JCO0FBWWY7QUFNSzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0EsSUFBSSwrQ0FBSywrQkFBK0IsNkNBQU87QUFDL0MsSUFBSSw4Q0FBSSxDQUFDLDZDQUFHLEtBQUssNkNBQUcsc0JBQXNCLDZDQUFPO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyw2Q0FBTztBQUN6QywyQkFBMkIsNkNBQU87QUFDbEMsYUFBYSw2Q0FBRztBQUNoQixtQkFBbUIsNkNBQUcsbUJBQW1CLDZDQUFHLFVBQVUsNkNBQUc7QUFDekQ7O0FBRUE7QUFDTztBQUNQO0FBQ0EsU0FBUywyREFBRyxjQUFjLDZEQUFLO0FBQy9COztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrREFBVztBQUN2QixpQkFBaUIsa0RBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsOENBQUk7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdXJhanJhd2F0L0Rvd25sb2Fkcy9UcmlweS9ub2RlX21vZHVsZXMvZDMtZ2VvLXZvcm9ub2kvc3JjL2RlbGF1bmF5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERlbGF1bmF5IH0gZnJvbSBcImQzLWRlbGF1bmF5XCI7XG5pbXBvcnQgeyBnZW9Sb3RhdGlvbiwgZ2VvU3RlcmVvZ3JhcGhpYyB9IGZyb20gXCJkMy1nZW9cIjtcbmltcG9ydCB7IGV4dGVudCB9IGZyb20gXCJkMy1hcnJheVwiO1xuaW1wb3J0IHtcbiAgYXNpbixcbiAgYXRhbjIsXG4gIGNvcyxcbiAgZGVncmVlcyxcbiAgbWF4LFxuICBtaW4sXG4gIHJhZGlhbnMsXG4gIHNpZ24sXG4gIHNpbixcbiAgc3FydCxcbn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuaW1wb3J0IHtcbiAgY2FydGVzaWFuTm9ybWFsaXplIGFzIG5vcm1hbGl6ZSxcbiAgY2FydGVzaWFuQ3Jvc3MgYXMgY3Jvc3MsXG4gIGNhcnRlc2lhbkRvdCBhcyBkb3QsXG4gIGNhcnRlc2lhbkFkZCxcbn0gZnJvbSBcIi4vY2FydGVzaWFuLmpzXCI7XG5cbi8vIENvbnZlcnRzIDNEIENhcnRlc2lhbiB0byBzcGhlcmljYWwgY29vcmRpbmF0ZXMgKGRlZ3JlZXMpLlxuZnVuY3Rpb24gc3BoZXJpY2FsKGNhcnRlc2lhbikge1xuICByZXR1cm4gW1xuICAgIGF0YW4yKGNhcnRlc2lhblsxXSwgY2FydGVzaWFuWzBdKSAqIGRlZ3JlZXMsXG4gICAgYXNpbihtYXgoLTEsIG1pbigxLCBjYXJ0ZXNpYW5bMl0pKSkgKiBkZWdyZWVzLFxuICBdO1xufVxuXG4vLyBDb252ZXJ0cyBzcGhlcmljYWwgY29vcmRpbmF0ZXMgKGRlZ3JlZXMpIHRvIDNEIENhcnRlc2lhbi5cbmZ1bmN0aW9uIGNhcnRlc2lhbihjb29yZGluYXRlcykge1xuICBjb25zdCBsYW1iZGEgPSBjb29yZGluYXRlc1swXSAqIHJhZGlhbnMsXG4gICAgcGhpID0gY29vcmRpbmF0ZXNbMV0gKiByYWRpYW5zLFxuICAgIGNvc3BoaSA9IGNvcyhwaGkpO1xuICByZXR1cm4gW2Nvc3BoaSAqIGNvcyhsYW1iZGEpLCBjb3NwaGkgKiBzaW4obGFtYmRhKSwgc2luKHBoaSldO1xufVxuXG4vLyBTcGhlcmljYWwgZXhjZXNzIG9mIGEgdHJpYW5nbGUgKGluIHNwaGVyaWNhbCBjb29yZGluYXRlcylcbmV4cG9ydCBmdW5jdGlvbiBleGNlc3ModHJpYW5nbGUpIHtcbiAgdHJpYW5nbGUgPSB0cmlhbmdsZS5tYXAoKHApID0+IGNhcnRlc2lhbihwKSk7XG4gIHJldHVybiBkb3QodHJpYW5nbGVbMF0sIGNyb3NzKHRyaWFuZ2xlWzJdLCB0cmlhbmdsZVsxXSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VvRGVsYXVuYXkocG9pbnRzKSB7XG4gIGNvbnN0IGRlbGF1bmF5ID0gZ2VvX2RlbGF1bmF5X2Zyb20ocG9pbnRzKSxcbiAgICB0cmlhbmdsZXMgPSBnZW9fdHJpYW5nbGVzKGRlbGF1bmF5KSxcbiAgICBlZGdlcyA9IGdlb19lZGdlcyh0cmlhbmdsZXMsIHBvaW50cyksXG4gICAgbmVpZ2hib3JzID0gZ2VvX25laWdoYm9ycyh0cmlhbmdsZXMsIHBvaW50cy5sZW5ndGgpLFxuICAgIGZpbmQgPSBnZW9fZmluZChuZWlnaGJvcnMsIHBvaW50cyksXG4gICAgLy8gVm9yb25vaSA7IGNvdWxkIHRha2UgYSBjZW50ZXIgZnVuY3Rpb24gYXMgYW4gYXJndW1lbnRcbiAgICBjaXJjdW1jZW50ZXJzID0gZ2VvX2NpcmN1bWNlbnRlcnModHJpYW5nbGVzLCBwb2ludHMpLFxuICAgIHsgcG9seWdvbnMsIGNlbnRlcnMgfSA9IGdlb19wb2x5Z29ucyhjaXJjdW1jZW50ZXJzLCB0cmlhbmdsZXMsIHBvaW50cyksXG4gICAgbWVzaCA9IGdlb19tZXNoKHBvbHlnb25zKSxcbiAgICBodWxsID0gZ2VvX2h1bGwodHJpYW5nbGVzLCBwb2ludHMpLFxuICAgIC8vIFVycXVoYXJ0IDsgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBkaXN0YW5jZSBhcnJheSBhcyBhcmd1bWVudC5cbiAgICB1cnF1aGFydCA9IGdlb191cnF1aGFydChlZGdlcywgdHJpYW5nbGVzKTtcbiAgcmV0dXJuIHtcbiAgICBkZWxhdW5heSxcbiAgICBlZGdlcyxcbiAgICB0cmlhbmdsZXMsXG4gICAgY2VudGVycyxcbiAgICBuZWlnaGJvcnMsXG4gICAgcG9seWdvbnMsXG4gICAgbWVzaCxcbiAgICBodWxsLFxuICAgIHVycXVoYXJ0LFxuICAgIGZpbmQsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlb19maW5kKG5laWdoYm9ycywgcG9pbnRzKSB7XG4gIGZ1bmN0aW9uIGRpc3RhbmNlMihhLCBiKSB7XG4gICAgbGV0IHggPSBhWzBdIC0gYlswXSxcbiAgICAgIHkgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHogPSBhWzJdIC0gYlsyXTtcbiAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGZpbmQoeCwgeSwgbmV4dCkge1xuICAgIGlmIChuZXh0ID09PSB1bmRlZmluZWQpIG5leHQgPSAwO1xuICAgIGxldCBjZWxsLFxuICAgICAgZGlzdCxcbiAgICAgIGZvdW5kID0gbmV4dDtcbiAgICBjb25zdCB4eXogPSBjYXJ0ZXNpYW4oW3gsIHldKTtcbiAgICBkbyB7XG4gICAgICBjZWxsID0gbmV4dDtcbiAgICAgIG5leHQgPSBudWxsO1xuICAgICAgZGlzdCA9IGRpc3RhbmNlMih4eXosIGNhcnRlc2lhbihwb2ludHNbY2VsbF0pKTtcbiAgICAgIG5laWdoYm9yc1tjZWxsXS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGxldCBuZGlzdCA9IGRpc3RhbmNlMih4eXosIGNhcnRlc2lhbihwb2ludHNbaV0pKTtcbiAgICAgICAgaWYgKG5kaXN0IDwgZGlzdCkge1xuICAgICAgICAgIGRpc3QgPSBuZGlzdDtcbiAgICAgICAgICBuZXh0ID0gaTtcbiAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IHdoaWxlIChuZXh0ICE9PSBudWxsKTtcblxuICAgIHJldHVybiBmb3VuZDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2VvX2RlbGF1bmF5X2Zyb20ocG9pbnRzKSB7XG4gIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcmV0dXJuIHt9O1xuXG4gIC8vIGZpbmQgYSB2YWxpZCBwb2ludCB0byBzZW5kIHRvIGluZmluaXR5XG4gIGxldCBwaXZvdCA9IDA7XG4gIHdoaWxlIChpc05hTihwb2ludHNbcGl2b3RdWzBdICsgcG9pbnRzW3Bpdm90XVsxXSkgJiYgcGl2b3QrKyA8IHBvaW50cy5sZW5ndGgpO1xuXG4gIGNvbnN0IHIgPSBnZW9Sb3RhdGlvbihwb2ludHNbcGl2b3RdKSxcbiAgICBwcm9qZWN0aW9uID0gZ2VvU3RlcmVvZ3JhcGhpYygpXG4gICAgICAudHJhbnNsYXRlKFswLCAwXSlcbiAgICAgIC5zY2FsZSgxKVxuICAgICAgLnJvdGF0ZShyLmludmVydChbMTgwLCAwXSkpO1xuICBwb2ludHMgPSBwb2ludHMubWFwKHByb2plY3Rpb24pO1xuXG4gIGNvbnN0IHplcm9zID0gW107XG4gIGxldCBtYXgyID0gMTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgbGV0IG0gPSBwb2ludHNbaV1bMF0gKiogMiArIHBvaW50c1tpXVsxXSAqKiAyO1xuICAgIGlmICghaXNGaW5pdGUobSkgfHwgbSA+IDFlMzIpIHplcm9zLnB1c2goaSk7XG4gICAgZWxzZSBpZiAobSA+IG1heDIpIG1heDIgPSBtO1xuICB9XG5cbiAgY29uc3QgRkFSID0gMWU2ICogc3FydChtYXgyKTtcblxuICB6ZXJvcy5mb3JFYWNoKChpKSA9PiAocG9pbnRzW2ldID0gW0ZBUiwgMF0pKTtcblxuICAvLyBBZGQgaW5maW5pdGUgaG9yaXpvbiBwb2ludHNcbiAgcG9pbnRzLnB1c2goWzAsIEZBUl0pO1xuICBwb2ludHMucHVzaChbLUZBUiwgMF0pO1xuICBwb2ludHMucHVzaChbMCwgLUZBUl0pO1xuXG4gIGNvbnN0IGRlbGF1bmF5ID0gRGVsYXVuYXkuZnJvbShwb2ludHMpO1xuXG4gIGRlbGF1bmF5LnByb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuXG4gIC8vIGNsZWFuIHVwIHRoZSB0cmlhbmd1bGF0aW9uXG4gIGNvbnN0IHsgdHJpYW5nbGVzLCBoYWxmZWRnZXMsIGluZWRnZXMgfSA9IGRlbGF1bmF5O1xuICBjb25zdCBkZWdlbmVyYXRlID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsID0gaGFsZmVkZ2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChoYWxmZWRnZXNbaV0gPCAwKSB7XG4gICAgICBjb25zdCBqID0gaSAlIDMgPT0gMiA/IGkgLSAyIDogaSArIDE7XG4gICAgICBjb25zdCBrID0gaSAlIDMgPT0gMCA/IGkgKyAyIDogaSAtIDE7XG4gICAgICBjb25zdCBhID0gaGFsZmVkZ2VzW2pdO1xuICAgICAgY29uc3QgYiA9IGhhbGZlZGdlc1trXTtcbiAgICAgIGhhbGZlZGdlc1thXSA9IGI7XG4gICAgICBoYWxmZWRnZXNbYl0gPSBhO1xuICAgICAgaGFsZmVkZ2VzW2pdID0gaGFsZmVkZ2VzW2tdID0gLTE7XG4gICAgICB0cmlhbmdsZXNbaV0gPSB0cmlhbmdsZXNbal0gPSB0cmlhbmdsZXNba10gPSBwaXZvdDtcbiAgICAgIGluZWRnZXNbdHJpYW5nbGVzW2FdXSA9IGEgJSAzID09IDAgPyBhICsgMiA6IGEgLSAxO1xuICAgICAgaW5lZGdlc1t0cmlhbmdsZXNbYl1dID0gYiAlIDMgPT0gMCA/IGIgKyAyIDogYiAtIDE7XG4gICAgICBkZWdlbmVyYXRlLnB1c2goTWF0aC5taW4oaSwgaiwgaykpO1xuICAgICAgaSArPSAyIC0gKGkgJSAzKTtcbiAgICB9IGVsc2UgaWYgKHRyaWFuZ2xlc1tpXSA+IHBvaW50cy5sZW5ndGggLSAzIC0gMSkge1xuICAgICAgdHJpYW5nbGVzW2ldID0gcGl2b3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gdGhlcmUgc2hvdWxkIGFsd2F5cyBiZSA0IGRlZ2VuZXJhdGUgdHJpYW5nbGVzXG4gIC8vIGNvbnNvbGUud2FybihkZWdlbmVyYXRlKTtcbiAgcmV0dXJuIGRlbGF1bmF5O1xufVxuXG5mdW5jdGlvbiBnZW9fZWRnZXModHJpYW5nbGVzLCBwb2ludHMpIHtcbiAgY29uc3QgX2luZGV4ID0gbmV3IFNldCgpO1xuICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIFtbMCwgMV1dO1xuICB0cmlhbmdsZXMuZm9yRWFjaCgodHJpKSA9PiB7XG4gICAgaWYgKHRyaVswXSA9PT0gdHJpWzFdKSByZXR1cm47XG4gICAgaWYgKGV4Y2Vzcyh0cmkubWFwKChpKSA9PiBwb2ludHNbaV0pKSA8IDApIHJldHVybjtcbiAgICBmb3IgKGxldCBpID0gMCwgajsgaSA8IDM7IGkrKykge1xuICAgICAgaiA9IChpICsgMSkgJSAzO1xuICAgICAgX2luZGV4LmFkZChleHRlbnQoW3RyaVtpXSwgdHJpW2pdXSkuam9pbihcIi1cIikpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBcnJheS5mcm9tKF9pbmRleCwgKGQpID0+IGQuc3BsaXQoXCItXCIpLm1hcChOdW1iZXIpKTtcbn1cblxuZnVuY3Rpb24gZ2VvX3RyaWFuZ2xlcyhkZWxhdW5heSkge1xuICBjb25zdCB7IHRyaWFuZ2xlcyB9ID0gZGVsYXVuYXk7XG4gIGlmICghdHJpYW5nbGVzKSByZXR1cm4gW107XG5cbiAgY29uc3QgZ2VvX3RyaWFuZ2xlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbiA9IHRyaWFuZ2xlcy5sZW5ndGggLyAzOyBpIDwgbjsgaSsrKSB7XG4gICAgY29uc3QgYSA9IHRyaWFuZ2xlc1szICogaV0sXG4gICAgICBiID0gdHJpYW5nbGVzWzMgKiBpICsgMV0sXG4gICAgICBjID0gdHJpYW5nbGVzWzMgKiBpICsgMl07XG4gICAgaWYgKGEgIT09IGIgJiYgYiAhPT0gYykge1xuICAgICAgZ2VvX3RyaWFuZ2xlcy5wdXNoKFthLCBjLCBiXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9fdHJpYW5nbGVzO1xufVxuXG5mdW5jdGlvbiBnZW9fY2lyY3VtY2VudGVycyh0cmlhbmdsZXMsIHBvaW50cykge1xuICAvLyBpZiAoIXVzZV9jZW50cm9pZHMpIHtcbiAgcmV0dXJuIHRyaWFuZ2xlcy5tYXAoKHRyaSkgPT4ge1xuICAgIGNvbnN0IGMgPSB0cmkubWFwKChpKSA9PiBwb2ludHNbaV0pLm1hcChjYXJ0ZXNpYW4pLFxuICAgICAgViA9IGNhcnRlc2lhbkFkZChcbiAgICAgICAgY2FydGVzaWFuQWRkKGNyb3NzKGNbMV0sIGNbMF0pLCBjcm9zcyhjWzJdLCBjWzFdKSksXG4gICAgICAgIGNyb3NzKGNbMF0sIGNbMl0pXG4gICAgICApO1xuICAgIHJldHVybiBzcGhlcmljYWwobm9ybWFsaXplKFYpKTtcbiAgfSk7XG4gIC8qfSBlbHNlIHtcbiAgICByZXR1cm4gdHJpYW5nbGVzLm1hcCh0cmkgPT4ge1xuICAgICAgcmV0dXJuIGQzLmdlb0NlbnRyb2lkKHtcbiAgICAgICAgdHlwZTogXCJNdWx0aVBvaW50XCIsXG4gICAgICAgIGNvb3JkaW5hdGVzOiB0cmkubWFwKGkgPT4gcG9pbnRzW2ldKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0qL1xufVxuXG5mdW5jdGlvbiBnZW9fbmVpZ2hib3JzKHRyaWFuZ2xlcywgbnBvaW50cykge1xuICBjb25zdCBuZWlnaGJvcnMgPSBbXTtcbiAgdHJpYW5nbGVzLmZvckVhY2goKHRyaSkgPT4ge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICBjb25zdCBhID0gdHJpW2pdLFxuICAgICAgICBiID0gdHJpWyhqICsgMSkgJSAzXTtcbiAgICAgIG5laWdoYm9yc1thXSA9IG5laWdoYm9yc1thXSB8fCBbXTtcbiAgICAgIG5laWdoYm9yc1thXS5wdXNoKGIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZGVnZW5lcmF0ZSBjYXNlc1xuICBpZiAodHJpYW5nbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChucG9pbnRzID09PSAyKSAobmVpZ2hib3JzWzBdID0gWzFdKSwgKG5laWdoYm9yc1sxXSA9IFswXSk7XG4gICAgZWxzZSBpZiAobnBvaW50cyA9PT0gMSkgbmVpZ2hib3JzWzBdID0gW107XG4gIH1cblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuXG5mdW5jdGlvbiBnZW9fcG9seWdvbnMoY2lyY3VtY2VudGVycywgdHJpYW5nbGVzLCBwb2ludHMpIHtcbiAgY29uc3QgcG9seWdvbnMgPSBbXTtcblxuICBjb25zdCBjZW50ZXJzID0gY2lyY3VtY2VudGVycy5zbGljZSgpO1xuXG4gIGlmICh0cmlhbmdsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSByZXR1cm4geyBwb2x5Z29ucywgY2VudGVycyB9O1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyB0d28gaGVtaXNwaGVyZXNcbiAgICAgIGNvbnN0IGEgPSBjYXJ0ZXNpYW4ocG9pbnRzWzBdKSxcbiAgICAgICAgYiA9IGNhcnRlc2lhbihwb2ludHNbMV0pLFxuICAgICAgICBtID0gbm9ybWFsaXplKGNhcnRlc2lhbkFkZChhLCBiKSksXG4gICAgICAgIGQgPSBub3JtYWxpemUoY3Jvc3MoYSwgYikpLFxuICAgICAgICBjID0gY3Jvc3MobSwgZCk7XG4gICAgICBjb25zdCBwb2x5ID0gW1xuICAgICAgICBtLFxuICAgICAgICBjcm9zcyhtLCBjKSxcbiAgICAgICAgY3Jvc3MoY3Jvc3MobSwgYyksIGMpLFxuICAgICAgICBjcm9zcyhjcm9zcyhjcm9zcyhtLCBjKSwgYyksIGMpLFxuICAgICAgXVxuICAgICAgICAubWFwKHNwaGVyaWNhbClcbiAgICAgICAgLm1hcChzdXBwbGVtZW50KTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvbHlnb25zLnB1c2gocG9seSksXG4gICAgICAgIHBvbHlnb25zLnB1c2gocG9seS5zbGljZSgpLnJldmVyc2UoKSksXG4gICAgICAgIHsgcG9seWdvbnMsIGNlbnRlcnMgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB0cmlhbmdsZXMuZm9yRWFjaCgodHJpLCB0KSA9PiB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgIGNvbnN0IGEgPSB0cmlbal0sXG4gICAgICAgIGIgPSB0cmlbKGogKyAxKSAlIDNdLFxuICAgICAgICBjID0gdHJpWyhqICsgMikgJSAzXTtcbiAgICAgIHBvbHlnb25zW2FdID0gcG9seWdvbnNbYV0gfHwgW107XG4gICAgICBwb2x5Z29uc1thXS5wdXNoKFtiLCBjLCB0LCBbYSwgYiwgY11dKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHJlb3JkZXIgZWFjaCBwb2x5Z29uXG4gIGNvbnN0IHJlb3JkZXJlZCA9IHBvbHlnb25zLm1hcCgocG9seSkgPT4ge1xuICAgIGNvbnN0IHAgPSBbcG9seVswXVsyXV07IC8vIHRcbiAgICBsZXQgayA9IHBvbHlbMF1bMV07IC8vIGsgPSBjXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsb29rIGZvciBiID0ga1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2x5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChwb2x5W2pdWzBdID09IGspIHtcbiAgICAgICAgICBrID0gcG9seVtqXVsxXTtcbiAgICAgICAgICBwLnB1c2gocG9seVtqXVsyXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocC5sZW5ndGggPiAyKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9IGVsc2UgaWYgKHAubGVuZ3RoID09IDIpIHtcbiAgICAgIGNvbnN0IFIwID0gb19taWRwb2ludChcbiAgICAgICAgICBwb2ludHNbcG9seVswXVszXVswXV0sXG4gICAgICAgICAgcG9pbnRzW3BvbHlbMF1bM11bMV1dLFxuICAgICAgICAgIGNlbnRlcnNbcFswXV1cbiAgICAgICAgKSxcbiAgICAgICAgUjEgPSBvX21pZHBvaW50KFxuICAgICAgICAgIHBvaW50c1twb2x5WzBdWzNdWzJdXSxcbiAgICAgICAgICBwb2ludHNbcG9seVswXVszXVswXV0sXG4gICAgICAgICAgY2VudGVyc1twWzBdXVxuICAgICAgICApO1xuICAgICAgY29uc3QgaTAgPSBzdXBwbGVtZW50KFIwKSxcbiAgICAgICAgaTEgPSBzdXBwbGVtZW50KFIxKTtcbiAgICAgIHJldHVybiBbcFswXSwgaTEsIHBbMV0sIGkwXTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHN1cHBsZW1lbnQocG9pbnQpIHtcbiAgICBsZXQgZiA9IC0xO1xuICAgIGNlbnRlcnMuc2xpY2UodHJpYW5nbGVzLmxlbmd0aCwgSW5maW5pdHkpLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgIGlmIChwWzBdID09PSBwb2ludFswXSAmJiBwWzFdID09PSBwb2ludFsxXSkgZiA9IGkgKyB0cmlhbmdsZXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIGlmIChmIDwgMCkgKGYgPSBjZW50ZXJzLmxlbmd0aCksIGNlbnRlcnMucHVzaChwb2ludCk7XG4gICAgcmV0dXJuIGY7XG4gIH1cblxuICByZXR1cm4geyBwb2x5Z29uczogcmVvcmRlcmVkLCBjZW50ZXJzIH07XG59XG5cbmZ1bmN0aW9uIG9fbWlkcG9pbnQoYSwgYiwgYykge1xuICBhID0gY2FydGVzaWFuKGEpO1xuICBiID0gY2FydGVzaWFuKGIpO1xuICBjID0gY2FydGVzaWFuKGMpO1xuICBjb25zdCBzID0gc2lnbihkb3QoY3Jvc3MoYiwgYSksIGMpKTtcbiAgcmV0dXJuIHNwaGVyaWNhbChub3JtYWxpemUoY2FydGVzaWFuQWRkKGEsIGIpKS5tYXAoKGQpID0+IHMgKiBkKSk7XG59XG5cbmZ1bmN0aW9uIGdlb19tZXNoKHBvbHlnb25zKSB7XG4gIGNvbnN0IG1lc2ggPSBbXTtcbiAgcG9seWdvbnMuZm9yRWFjaCgocG9seSkgPT4ge1xuICAgIGlmICghcG9seSkgcmV0dXJuO1xuICAgIGxldCBwID0gcG9seVtwb2x5Lmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IHEgb2YgcG9seSkge1xuICAgICAgaWYgKHEgPiBwKSBtZXNoLnB1c2goW3AsIHFdKTtcbiAgICAgIHAgPSBxO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtZXNoO1xufVxuXG5mdW5jdGlvbiBnZW9fdXJxdWhhcnQoZWRnZXMsIHRyaWFuZ2xlcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGRpc3RhbmNlcykge1xuICAgIGNvbnN0IF9sZW5ndGhzID0gbmV3IE1hcCgpLFxuICAgICAgX3VycXVoYXJ0ID0gbmV3IE1hcCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UsIGkpID0+IHtcbiAgICAgIGNvbnN0IHUgPSBlZGdlLmpvaW4oXCItXCIpO1xuICAgICAgX2xlbmd0aHMuc2V0KHUsIGRpc3RhbmNlc1tpXSk7XG4gICAgICBfdXJxdWhhcnQuc2V0KHUsIHRydWUpO1xuICAgIH0pO1xuXG4gICAgdHJpYW5nbGVzLmZvckVhY2goKHRyaSkgPT4ge1xuICAgICAgbGV0IGwgPSAwLFxuICAgICAgICByZW1vdmUgPSAtMTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIGxldCB1ID0gZXh0ZW50KFt0cmlbal0sIHRyaVsoaiArIDEpICUgM11dKS5qb2luKFwiLVwiKTtcbiAgICAgICAgaWYgKF9sZW5ndGhzLmdldCh1KSA+IGwpIHtcbiAgICAgICAgICBsID0gX2xlbmd0aHMuZ2V0KHUpO1xuICAgICAgICAgIHJlbW92ZSA9IHU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF91cnF1aGFydC5zZXQocmVtb3ZlLCBmYWxzZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZWRnZXMubWFwKChlZGdlKSA9PiBfdXJxdWhhcnQuZ2V0KGVkZ2Uuam9pbihcIi1cIikpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2VvX2h1bGwodHJpYW5nbGVzLCBwb2ludHMpIHtcbiAgY29uc3QgX2h1bGwgPSBuZXcgU2V0KCksXG4gICAgaHVsbCA9IFtdO1xuICB0cmlhbmdsZXMubWFwKCh0cmkpID0+IHtcbiAgICBpZiAoZXhjZXNzKHRyaS5tYXAoKGkpID0+IHBvaW50c1tpID4gcG9pbnRzLmxlbmd0aCA/IDAgOiBpXSkpID4gMWUtMTIpXG4gICAgICByZXR1cm47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGxldCBlID0gW3RyaVtpXSwgdHJpWyhpICsgMSkgJSAzXV0sXG4gICAgICAgIGNvZGUgPSBgJHtlWzBdfS0ke2VbMV19YDtcbiAgICAgIGlmIChfaHVsbC5oYXMoY29kZSkpIF9odWxsLmRlbGV0ZShjb2RlKTtcbiAgICAgIGVsc2UgX2h1bGwuYWRkKGAke2VbMV19LSR7ZVswXX1gKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IF9pbmRleCA9IG5ldyBNYXAoKTtcbiAgbGV0IHN0YXJ0O1xuICBfaHVsbC5mb3JFYWNoKChlKSA9PiB7XG4gICAgZSA9IGUuc3BsaXQoXCItXCIpLm1hcChOdW1iZXIpO1xuICAgIF9pbmRleC5zZXQoZVswXSwgZVsxXSk7XG4gICAgc3RhcnQgPSBlWzBdO1xuICB9KTtcblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGh1bGw7XG5cbiAgbGV0IG5leHQgPSBzdGFydDtcbiAgZG8ge1xuICAgIGh1bGwucHVzaChuZXh0KTtcbiAgICBsZXQgbiA9IF9pbmRleC5nZXQobmV4dCk7XG4gICAgX2luZGV4LnNldChuZXh0LCAtMSk7XG4gICAgbmV4dCA9IG47XG4gIH0gd2hpbGUgKG5leHQgPiAtMSAmJiBuZXh0ICE9PSBzdGFydCk7XG5cbiAgcmV0dXJuIGh1bGw7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-geo-voronoi/src/delaunay.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/d3-geo-voronoi/src/math.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-geo-voronoi/src/math.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abs: () => (/* binding */ abs),\n/* harmony export */   acos: () => (/* binding */ acos),\n/* harmony export */   asin: () => (/* binding */ asin),\n/* harmony export */   atan: () => (/* binding */ atan),\n/* harmony export */   atan2: () => (/* binding */ atan2),\n/* harmony export */   ceil: () => (/* binding */ ceil),\n/* harmony export */   cos: () => (/* binding */ cos),\n/* harmony export */   degrees: () => (/* binding */ degrees),\n/* harmony export */   epsilon: () => (/* binding */ epsilon),\n/* harmony export */   epsilon2: () => (/* binding */ epsilon2),\n/* harmony export */   exp: () => (/* binding */ exp),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   halfPi: () => (/* binding */ halfPi),\n/* harmony export */   haversin: () => (/* binding */ haversin),\n/* harmony export */   log: () => (/* binding */ log),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   pi: () => (/* binding */ pi),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   quarterPi: () => (/* binding */ quarterPi),\n/* harmony export */   radians: () => (/* binding */ radians),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   sin: () => (/* binding */ sin),\n/* harmony export */   sqrt: () => (/* binding */ sqrt),\n/* harmony export */   tan: () => (/* binding */ tan),\n/* harmony export */   tau: () => (/* binding */ tau)\n/* harmony export */ });\nconst epsilon = 1e-6;\nconst epsilon2 = 1e-12;\nconst pi = Math.PI;\nconst halfPi = pi / 2;\nconst quarterPi = pi / 4;\nconst tau = pi * 2;\n\nconst degrees = 180 / pi;\nconst radians = pi / 180;\n\nconst abs = Math.abs;\nconst atan = Math.atan;\nconst atan2 = Math.atan2;\nconst cos = Math.cos;\nconst ceil = Math.ceil;\nconst exp = Math.exp;\nconst floor = Math.floor;\nconst log = Math.log;\nconst max = Math.max;\nconst min = Math.min;\nconst pow = Math.pow;\nconst sin = Math.sin;\nconst sign =\n  Math.sign ||\n  function (x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n  };\nconst sqrt = Math.sqrt;\nconst tan = Math.tan;\n\nfunction acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nfunction asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nfunction haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXZvcm9ub2kvc3JjL21hdGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTs7QUFFQTtBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3N1cmFqcmF3YXQvRG93bmxvYWRzL1RyaXB5L25vZGVfbW9kdWxlcy9kMy1nZW8tdm9yb25vaS9zcmMvbWF0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG5leHBvcnQgY29uc3QgZXBzaWxvbjIgPSAxZS0xMjtcbmV4cG9ydCBjb25zdCBwaSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgaGFsZlBpID0gcGkgLyAyO1xuZXhwb3J0IGNvbnN0IHF1YXJ0ZXJQaSA9IHBpIC8gNDtcbmV4cG9ydCBjb25zdCB0YXUgPSBwaSAqIDI7XG5cbmV4cG9ydCBjb25zdCBkZWdyZWVzID0gMTgwIC8gcGk7XG5leHBvcnQgY29uc3QgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgY29uc3QgYWJzID0gTWF0aC5hYnM7XG5leHBvcnQgY29uc3QgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCBjb25zdCBhdGFuMiA9IE1hdGguYXRhbjI7XG5leHBvcnQgY29uc3QgY29zID0gTWF0aC5jb3M7XG5leHBvcnQgY29uc3QgY2VpbCA9IE1hdGguY2VpbDtcbmV4cG9ydCBjb25zdCBleHAgPSBNYXRoLmV4cDtcbmV4cG9ydCBjb25zdCBmbG9vciA9IE1hdGguZmxvb3I7XG5leHBvcnQgY29uc3QgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgY29uc3QgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgY29uc3QgbWluID0gTWF0aC5taW47XG5leHBvcnQgY29uc3QgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgY29uc3Qgc2luID0gTWF0aC5zaW47XG5leHBvcnQgY29uc3Qgc2lnbiA9XG4gIE1hdGguc2lnbiB8fFxuICBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDtcbiAgfTtcbmV4cG9ydCBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0O1xuZXhwb3J0IGNvbnN0IHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgZnVuY3Rpb24gYWNvcyh4KSB7XG4gIHJldHVybiB4ID4gMSA/IDAgOiB4IDwgLTEgPyBwaSA6IE1hdGguYWNvcyh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGF2ZXJzaW4oeCkge1xuICByZXR1cm4gKHggPSBzaW4oeCAvIDIpKSAqIHg7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-geo-voronoi/src/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/d3-geo-voronoi/src/voronoi.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-voronoi/src/voronoi.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   geoVoronoi: () => (/* binding */ geoVoronoi)\n/* harmony export */ });\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/centroid.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/distance.js\");\n/* harmony import */ var _delaunay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./delaunay.js */ \"(ssr)/./node_modules/d3-geo-voronoi/src/delaunay.js\");\n\n\n\nfunction geoVoronoi(data) {\n  const v = function (data) {\n    v.delaunay = null;\n    v._data = data;\n\n    if (typeof v._data === \"object\" && v._data.type === \"FeatureCollection\") {\n      v._data = v._data.features;\n    }\n    if (typeof v._data === \"object\") {\n      const temp = v._data\n        .map((d) => [v._vx(d), v._vy(d), d])\n        .filter((d) => isFinite(d[0] + d[1]));\n      v.points = temp.map((d) => [d[0], d[1]]);\n      v.valid = temp.map((d) => d[2]);\n      v.delaunay = (0,_delaunay_js__WEBPACK_IMPORTED_MODULE_0__.geoDelaunay)(v.points);\n    }\n    return v;\n  };\n\n  v._vx = function (d) {\n    if (typeof d == \"object\" && \"type\" in d) {\n      return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d)[0];\n    }\n    if (0 in d) return d[0];\n  };\n  v._vy = function (d) {\n    if (typeof d == \"object\" && \"type\" in d) {\n      return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(d)[1];\n    }\n    if (1 in d) return d[1];\n  };\n\n  v.x = function (f) {\n    if (!f) return v._vx;\n    v._vx = f;\n    return v;\n  };\n  v.y = function (f) {\n    if (!f) return v._vy;\n    v._vy = f;\n    return v;\n  };\n\n  v.polygons = function (data) {\n    if (data !== undefined) {\n      v(data);\n    }\n\n    if (!v.delaunay) return false;\n    const coll = {\n      type: \"FeatureCollection\",\n      features: [],\n    };\n    if (v.valid.length === 0) return coll;\n    v.delaunay.polygons.forEach((poly, i) =>\n      coll.features.push({\n        type: \"Feature\",\n        geometry: !poly\n          ? null\n          : {\n              type: \"Polygon\",\n              coordinates: [\n                [...poly, poly[0]].map((i) => v.delaunay.centers[i]),\n              ],\n            },\n        properties: {\n          site: v.valid[i],\n          sitecoordinates: v.points[i],\n          neighbours: v.delaunay.neighbors[i], // not part of the public API\n        },\n      })\n    );\n    if (v.valid.length === 1)\n      coll.features.push({\n        type: \"Feature\",\n        geometry: { type: \"Sphere\" },\n        properties: {\n          site: v.valid[0],\n          sitecoordinates: v.points[0],\n          neighbours: [],\n        },\n      });\n    return coll;\n  };\n\n  v.triangles = function (data) {\n    if (data !== undefined) {\n      v(data);\n    }\n    if (!v.delaunay) return false;\n\n    return {\n      type: \"FeatureCollection\",\n      features: v.delaunay.triangles\n        .map((tri, index) => {\n          tri = tri.map((i) => v.points[i]);\n          tri.center = v.delaunay.centers[index];\n          return tri;\n        })\n        .filter((tri) => (0,_delaunay_js__WEBPACK_IMPORTED_MODULE_0__.excess)(tri) > 0)\n        .map((tri) => ({\n          type: \"Feature\",\n          properties: {\n            circumcenter: tri.center,\n          },\n          geometry: {\n            type: \"Polygon\",\n            coordinates: [[...tri, tri[0]]],\n          },\n        })),\n    };\n  };\n\n  v.links = function (data) {\n    if (data !== undefined) {\n      v(data);\n    }\n    if (!v.delaunay) return false;\n    const _distances = v.delaunay.edges.map((e) =>\n        (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(v.points[e[0]], v.points[e[1]])\n      ),\n      _urquart = v.delaunay.urquhart(_distances);\n    return {\n      type: \"FeatureCollection\",\n      features: v.delaunay.edges.map((e, i) => ({\n        type: \"Feature\",\n        properties: {\n          source: v.valid[e[0]],\n          target: v.valid[e[1]],\n          length: _distances[i],\n          urquhart: !!_urquart[i],\n        },\n        geometry: {\n          type: \"LineString\",\n          coordinates: [v.points[e[0]], v.points[e[1]]],\n        },\n      })),\n    };\n  };\n\n  v.mesh = function (data) {\n    if (data !== undefined) {\n      v(data);\n    }\n    if (!v.delaunay) return false;\n    return {\n      type: \"MultiLineString\",\n      coordinates: v.delaunay.edges.map((e) => [\n        v.points[e[0]],\n        v.points[e[1]],\n      ]),\n    };\n  };\n\n  v.cellMesh = function (data) {\n    if (data !== undefined) {\n      v(data);\n    }\n    if (!v.delaunay) return false;\n    const { centers, polygons } = v.delaunay;\n    const coordinates = [];\n    for (const p of polygons) {\n      if (!p) continue;\n      for (\n        let n = p.length, p0 = p[n - 1], p1 = p[0], i = 0;\n        i < n;\n        p0 = p1, p1 = p[++i]\n      ) {\n        if (p1 > p0) {\n          coordinates.push([centers[p0], centers[p1]]);\n        }\n      }\n    }\n    return {\n      type: \"MultiLineString\",\n      coordinates,\n    };\n  };\n\n  v._found = undefined;\n  v.find = function (x, y, radius) {\n    v._found = v.delaunay.find(x, y, v._found);\n    if (!radius || (0,d3_geo__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([x, y], v.points[v._found]) < radius)\n      return v._found;\n  };\n\n  v.hull = function (data) {\n    if (data !== undefined) {\n      v(data);\n    }\n    const hull = v.delaunay.hull,\n      points = v.points;\n    return hull.length === 0\n      ? null\n      : {\n          type: \"Polygon\",\n          coordinates: [[...hull.map((i) => points[i]), points[hull[0]]]],\n        };\n  };\n\n  return data ? v(data) : v;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXZvcm9ub2kvc3JjL3Zvcm9ub2kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrRDtBQUNFOztBQUU3QztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQVc7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtEQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtEQUFXO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUJBQXlCLG9EQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtEQUFXO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3N1cmFqcmF3YXQvRG93bmxvYWRzL1RyaXB5L25vZGVfbW9kdWxlcy9kMy1nZW8tdm9yb25vaS9zcmMvdm9yb25vaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZW9DZW50cm9pZCwgZ2VvRGlzdGFuY2UgfSBmcm9tIFwiZDMtZ2VvXCI7XG5pbXBvcnQgeyBnZW9EZWxhdW5heSwgZXhjZXNzIH0gZnJvbSBcIi4vZGVsYXVuYXkuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdlb1Zvcm9ub2koZGF0YSkge1xuICBjb25zdCB2ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2LmRlbGF1bmF5ID0gbnVsbDtcbiAgICB2Ll9kYXRhID0gZGF0YTtcblxuICAgIGlmICh0eXBlb2Ygdi5fZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB2Ll9kYXRhLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xuICAgICAgdi5fZGF0YSA9IHYuX2RhdGEuZmVhdHVyZXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygdi5fZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdGVtcCA9IHYuX2RhdGFcbiAgICAgICAgLm1hcCgoZCkgPT4gW3YuX3Z4KGQpLCB2Ll92eShkKSwgZF0pXG4gICAgICAgIC5maWx0ZXIoKGQpID0+IGlzRmluaXRlKGRbMF0gKyBkWzFdKSk7XG4gICAgICB2LnBvaW50cyA9IHRlbXAubWFwKChkKSA9PiBbZFswXSwgZFsxXV0pO1xuICAgICAgdi52YWxpZCA9IHRlbXAubWFwKChkKSA9PiBkWzJdKTtcbiAgICAgIHYuZGVsYXVuYXkgPSBnZW9EZWxhdW5heSh2LnBvaW50cyk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHYuX3Z4ID0gZnVuY3Rpb24gKGQpIHtcbiAgICBpZiAodHlwZW9mIGQgPT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBkKSB7XG4gICAgICByZXR1cm4gZ2VvQ2VudHJvaWQoZClbMF07XG4gICAgfVxuICAgIGlmICgwIGluIGQpIHJldHVybiBkWzBdO1xuICB9O1xuICB2Ll92eSA9IGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKHR5cGVvZiBkID09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gZCkge1xuICAgICAgcmV0dXJuIGdlb0NlbnRyb2lkKGQpWzFdO1xuICAgIH1cbiAgICBpZiAoMSBpbiBkKSByZXR1cm4gZFsxXTtcbiAgfTtcblxuICB2LnggPSBmdW5jdGlvbiAoZikge1xuICAgIGlmICghZikgcmV0dXJuIHYuX3Z4O1xuICAgIHYuX3Z4ID0gZjtcbiAgICByZXR1cm4gdjtcbiAgfTtcbiAgdi55ID0gZnVuY3Rpb24gKGYpIHtcbiAgICBpZiAoIWYpIHJldHVybiB2Ll92eTtcbiAgICB2Ll92eSA9IGY7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdi5wb2x5Z29ucyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdihkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoIXYuZGVsYXVuYXkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBjb2xsID0ge1xuICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgZmVhdHVyZXM6IFtdLFxuICAgIH07XG4gICAgaWYgKHYudmFsaWQubGVuZ3RoID09PSAwKSByZXR1cm4gY29sbDtcbiAgICB2LmRlbGF1bmF5LnBvbHlnb25zLmZvckVhY2goKHBvbHksIGkpID0+XG4gICAgICBjb2xsLmZlYXR1cmVzLnB1c2goe1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgZ2VvbWV0cnk6ICFwb2x5XG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgICBjb29yZGluYXRlczogW1xuICAgICAgICAgICAgICAgIFsuLi5wb2x5LCBwb2x5WzBdXS5tYXAoKGkpID0+IHYuZGVsYXVuYXkuY2VudGVyc1tpXSksXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgc2l0ZTogdi52YWxpZFtpXSxcbiAgICAgICAgICBzaXRlY29vcmRpbmF0ZXM6IHYucG9pbnRzW2ldLFxuICAgICAgICAgIG5laWdoYm91cnM6IHYuZGVsYXVuYXkubmVpZ2hib3JzW2ldLCAvLyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICApO1xuICAgIGlmICh2LnZhbGlkLmxlbmd0aCA9PT0gMSlcbiAgICAgIGNvbGwuZmVhdHVyZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgICBnZW9tZXRyeTogeyB0eXBlOiBcIlNwaGVyZVwiIH0sXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBzaXRlOiB2LnZhbGlkWzBdLFxuICAgICAgICAgIHNpdGVjb29yZGluYXRlczogdi5wb2ludHNbMF0sXG4gICAgICAgICAgbmVpZ2hib3VyczogW10sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICByZXR1cm4gY29sbDtcbiAgfTtcblxuICB2LnRyaWFuZ2xlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdihkYXRhKTtcbiAgICB9XG4gICAgaWYgKCF2LmRlbGF1bmF5KSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgZmVhdHVyZXM6IHYuZGVsYXVuYXkudHJpYW5nbGVzXG4gICAgICAgIC5tYXAoKHRyaSwgaW5kZXgpID0+IHtcbiAgICAgICAgICB0cmkgPSB0cmkubWFwKChpKSA9PiB2LnBvaW50c1tpXSk7XG4gICAgICAgICAgdHJpLmNlbnRlciA9IHYuZGVsYXVuYXkuY2VudGVyc1tpbmRleF07XG4gICAgICAgICAgcmV0dXJuIHRyaTtcbiAgICAgICAgfSlcbiAgICAgICAgLmZpbHRlcigodHJpKSA9PiBleGNlc3ModHJpKSA+IDApXG4gICAgICAgIC5tYXAoKHRyaSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBjaXJjdW1jZW50ZXI6IHRyaS5jZW50ZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgdHlwZTogXCJQb2x5Z29uXCIsXG4gICAgICAgICAgICBjb29yZGluYXRlczogW1suLi50cmksIHRyaVswXV1dLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pKSxcbiAgICB9O1xuICB9O1xuXG4gIHYubGlua3MgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHYoZGF0YSk7XG4gICAgfVxuICAgIGlmICghdi5kZWxhdW5heSkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IF9kaXN0YW5jZXMgPSB2LmRlbGF1bmF5LmVkZ2VzLm1hcCgoZSkgPT5cbiAgICAgICAgZ2VvRGlzdGFuY2Uodi5wb2ludHNbZVswXV0sIHYucG9pbnRzW2VbMV1dKVxuICAgICAgKSxcbiAgICAgIF91cnF1YXJ0ID0gdi5kZWxhdW5heS51cnF1aGFydChfZGlzdGFuY2VzKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgZmVhdHVyZXM6IHYuZGVsYXVuYXkuZWRnZXMubWFwKChlLCBpKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHNvdXJjZTogdi52YWxpZFtlWzBdXSxcbiAgICAgICAgICB0YXJnZXQ6IHYudmFsaWRbZVsxXV0sXG4gICAgICAgICAgbGVuZ3RoOiBfZGlzdGFuY2VzW2ldLFxuICAgICAgICAgIHVycXVoYXJ0OiAhIV91cnF1YXJ0W2ldLFxuICAgICAgICB9LFxuICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBbdi5wb2ludHNbZVswXV0sIHYucG9pbnRzW2VbMV1dXSxcbiAgICAgICAgfSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9O1xuXG4gIHYubWVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdihkYXRhKTtcbiAgICB9XG4gICAgaWYgKCF2LmRlbGF1bmF5KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgICBjb29yZGluYXRlczogdi5kZWxhdW5heS5lZGdlcy5tYXAoKGUpID0+IFtcbiAgICAgICAgdi5wb2ludHNbZVswXV0sXG4gICAgICAgIHYucG9pbnRzW2VbMV1dLFxuICAgICAgXSksXG4gICAgfTtcbiAgfTtcblxuICB2LmNlbGxNZXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2KGRhdGEpO1xuICAgIH1cbiAgICBpZiAoIXYuZGVsYXVuYXkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IGNlbnRlcnMsIHBvbHlnb25zIH0gPSB2LmRlbGF1bmF5O1xuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW107XG4gICAgZm9yIChjb25zdCBwIG9mIHBvbHlnb25zKSB7XG4gICAgICBpZiAoIXApIGNvbnRpbnVlO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IG4gPSBwLmxlbmd0aCwgcDAgPSBwW24gLSAxXSwgcDEgPSBwWzBdLCBpID0gMDtcbiAgICAgICAgaSA8IG47XG4gICAgICAgIHAwID0gcDEsIHAxID0gcFsrK2ldXG4gICAgICApIHtcbiAgICAgICAgaWYgKHAxID4gcDApIHtcbiAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKFtjZW50ZXJzW3AwXSwgY2VudGVyc1twMV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgIGNvb3JkaW5hdGVzLFxuICAgIH07XG4gIH07XG5cbiAgdi5fZm91bmQgPSB1bmRlZmluZWQ7XG4gIHYuZmluZCA9IGZ1bmN0aW9uICh4LCB5LCByYWRpdXMpIHtcbiAgICB2Ll9mb3VuZCA9IHYuZGVsYXVuYXkuZmluZCh4LCB5LCB2Ll9mb3VuZCk7XG4gICAgaWYgKCFyYWRpdXMgfHwgZ2VvRGlzdGFuY2UoW3gsIHldLCB2LnBvaW50c1t2Ll9mb3VuZF0pIDwgcmFkaXVzKVxuICAgICAgcmV0dXJuIHYuX2ZvdW5kO1xuICB9O1xuXG4gIHYuaHVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdihkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgaHVsbCA9IHYuZGVsYXVuYXkuaHVsbCxcbiAgICAgIHBvaW50cyA9IHYucG9pbnRzO1xuICAgIHJldHVybiBodWxsLmxlbmd0aCA9PT0gMFxuICAgICAgPyBudWxsXG4gICAgICA6IHtcbiAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIixcbiAgICAgICAgICBjb29yZGluYXRlczogW1suLi5odWxsLm1hcCgoaSkgPT4gcG9pbnRzW2ldKSwgcG9pbnRzW2h1bGxbMF1dXV0sXG4gICAgICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIGRhdGEgPyB2KGRhdGEpIDogdjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/d3-geo-voronoi/src/voronoi.js\n");

/***/ })

};
;