"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-slippy-map-globe";
exports.ids = ["vendor-chunks/three-slippy-map-globe"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ThreeSlippyMapGlobe)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var d3_octree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-octree */ \"(ssr)/./node_modules/d3-octree/src/octree.js\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/linear.js\");\n/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-geo */ \"(ssr)/./node_modules/d3-geo/src/projection/mercator.js\");\n\n\n\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertClassBrand(e, t, n) {\n  if (\"function\" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;\n  throw new TypeError(\"Private element is not present on this object\");\n}\nfunction _assertThisInitialized(e) {\n  if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _checkPrivateRedeclaration(e, t) {\n  if (t.has(e)) throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _classPrivateFieldGet2(s, a) {\n  return s.get(_assertClassBrand(s, a));\n}\nfunction _classPrivateFieldInitSpec(e, t, a) {\n  _checkPrivateRedeclaration(e, t), t.set(e, a);\n}\nfunction _classPrivateFieldSet2(s, a, r) {\n  return s.set(_assertClassBrand(s, a), r), r;\n}\nfunction _classPrivateMethodInitSpec(e, a) {\n  _checkPrivateRedeclaration(e, a), a.add(e);\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (undefined !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (String )(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\n\nvar _materialDispose = function materialDispose(material) {\n  if (material instanceof Array) {\n    material.forEach(_materialDispose);\n  } else {\n    if (material.map) {\n      material.map.dispose();\n    }\n    material.dispose();\n  }\n};\nvar _deallocate = function deallocate(obj) {\n  if (obj.geometry) {\n    obj.geometry.dispose();\n  }\n  if (obj.material) {\n    _materialDispose(obj.material);\n  }\n  if (obj.texture) {\n    obj.texture.dispose();\n  }\n  if (obj.children) {\n    obj.children.forEach(_deallocate);\n  }\n};\nvar emptyObject = function emptyObject(obj) {\n  if (obj && obj.children) while (obj.children.length) {\n    var childObj = obj.children[0];\n    obj.remove(childObj);\n    _deallocate(childObj);\n  }\n};\n\nfunction polar2Cartesian(lat, lng, r) {\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return {\n    x: r * Math.sin(phi) * Math.cos(theta),\n    y: r * Math.cos(phi),\n    z: r * Math.sin(phi) * Math.sin(theta)\n  };\n}\nfunction cartesian2Polar(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    z = _ref.z;\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var phi = Math.acos(y / r);\n  var theta = Math.atan2(z, x);\n  return {\n    lat: 90 - phi * 180 / Math.PI,\n    lng: 90 - theta * 180 / Math.PI - (theta < -Math.PI / 2 ? 360 : 0),\n    // keep within [-180, 180] boundaries\n    r: r\n  };\n}\nfunction deg2Rad(deg) {\n  return deg * Math.PI / 180;\n}\n\nvar yMercatorScale = function yMercatorScale(y) {\n  return 1 - ((0,d3_geo__WEBPACK_IMPORTED_MODULE_0__.mercatorRaw)(0, (0.5 - y) * Math.PI)[1] / Math.PI + 1) / 2;\n};\nvar yMercatorScaleClamped = function yMercatorScaleClamped(y) {\n  return Math.max(0, Math.min(1, yMercatorScale(y)));\n};\nvar yMercatorScaleInvert = function yMercatorScaleInvert(y) {\n  return 0.5 - d3_geo__WEBPACK_IMPORTED_MODULE_0__.mercatorRaw.invert(0, (2 * (1 - y) - 1) * Math.PI)[1] / Math.PI;\n};\nvar convertMercatorUV = function convertMercatorUV(uvs) {\n  var y0 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var y1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var offsetScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().domain([1, 0]).range([y0, y1]).clamp(true);\n  var revOffsetScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__[\"default\"])().domain([yMercatorScaleClamped(y0), yMercatorScaleClamped(y1)]).range([1, 0]).clamp(true);\n  var scale = function scale(v) {\n    return revOffsetScale(yMercatorScaleClamped(offsetScale(v)));\n  };\n  var arr = uvs.array;\n  for (var i = 0, len = arr.length; i < len; i += 2) {\n    arr[i + 1] = scale(arr[i + 1]);\n  }\n  uvs.needsUpdate = true;\n};\n\nvar findTileXY = function findTileXY(level, isMercator, lng, lat) {\n  var gridSize = Math.pow(2, level);\n  var x = Math.max(0, Math.min(gridSize - 1, Math.floor((lng + 180) * gridSize / 360)));\n  var relY = (90 - lat) / 180;\n  isMercator && (relY = Math.max(0, Math.min(1, yMercatorScale(relY))));\n  var y = Math.floor(relY * gridSize);\n  return [x, y];\n};\nvar genTilesCoords = function genTilesCoords(level, isMercator) {\n  var x0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var y0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var _x1 = arguments.length > 4 ? arguments[4] : undefined;\n  var _y1 = arguments.length > 5 ? arguments[5] : undefined;\n  var tiles = [];\n  var gridSize = Math.pow(2, level);\n  var tileLngLen = 360 / gridSize;\n  var regTileLatLen = 180 / gridSize;\n  var x1 = _x1 === undefined ? gridSize - 1 : _x1;\n  var y1 = _y1 === undefined ? gridSize - 1 : _y1;\n  for (var x = x0, maxX = Math.min(gridSize - 1, x1); x <= maxX; x++) {\n    for (var y = y0, maxY = Math.min(gridSize - 1, y1); y <= maxY; y++) {\n      var reproY = y,\n        tileLatLen = regTileLatLen;\n      if (isMercator) {\n        // lat needs reprojection, but stretch to cover poles\n        reproY = y === 0 ? y : yMercatorScaleInvert(y / gridSize) * gridSize;\n        var reproYEnd = y + 1 === gridSize ? y + 1 : yMercatorScaleInvert((y + 1) / gridSize) * gridSize;\n        tileLatLen = (reproYEnd - reproY) * 180 / gridSize;\n      }\n\n      // tile centroid coordinates\n      var lng = -180 + (x + 0.5) * tileLngLen;\n      var lat = 90 - (reproY * 180 / gridSize + tileLatLen / 2);\n      var latLen = tileLatLen; // lng is always constant among all tiles\n\n      tiles.push({\n        x: x,\n        y: y,\n        lng: lng,\n        lat: lat,\n        latLen: latLen\n      });\n    }\n  }\n  return tiles;\n};\n\nvar MAX_LEVEL_TO_RENDER_ALL_TILES = 6; // level 6 = 4096 tiles\nvar MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE = 7; // octrees consume too much memory on higher levels, generate tiles on demand for those (based on globe surface distance) as the distortion is negligible\nvar TILE_SEARCH_RADIUS_CAMERA_DISTANCE = 3; // Euclidean distance factor, in units of camera distance to surface\nvar TILE_SEARCH_RADIUS_SURFACE_DISTANCE = 90; // in degrees on the globe surface, relative to camera altitude in globe radius units\nvar _radius = /*#__PURE__*/new WeakMap();\nvar _isMercator = /*#__PURE__*/new WeakMap();\nvar _tileUrl = /*#__PURE__*/new WeakMap();\nvar _level = /*#__PURE__*/new WeakMap();\nvar _tilesMeta = /*#__PURE__*/new WeakMap();\nvar _isInView = /*#__PURE__*/new WeakMap();\nvar _camera = /*#__PURE__*/new WeakMap();\nvar _innerBackLayer = /*#__PURE__*/new WeakMap();\nvar _ThreeSlippyMapGlobe_brand = /*#__PURE__*/new WeakSet();\nvar ThreeSlippyMapGlobe = /*#__PURE__*/function (_Group) {\n  function ThreeSlippyMapGlobe(radius) {\n    var _this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      tileUrl = _ref.tileUrl,\n      _ref$minLevel = _ref.minLevel,\n      minLevel = _ref$minLevel === undefined ? 0 : _ref$minLevel,\n      _ref$maxLevel = _ref.maxLevel,\n      maxLevel = _ref$maxLevel === undefined ? 17 : _ref$maxLevel,\n      _ref$mercatorProjecti = _ref.mercatorProjection,\n      mercatorProjection = _ref$mercatorProjecti === undefined ? true : _ref$mercatorProjecti;\n    _classCallCheck(this, ThreeSlippyMapGlobe);\n    _this = _callSuper(this, ThreeSlippyMapGlobe);\n    // Private methods\n    _classPrivateMethodInitSpec(_this, _ThreeSlippyMapGlobe_brand);\n    // Private attributes\n    _classPrivateFieldInitSpec(_this, _radius, undefined);\n    _classPrivateFieldInitSpec(_this, _isMercator, undefined);\n    _classPrivateFieldInitSpec(_this, _tileUrl, undefined);\n    _classPrivateFieldInitSpec(_this, _level, undefined);\n    _classPrivateFieldInitSpec(_this, _tilesMeta, {});\n    _classPrivateFieldInitSpec(_this, _isInView, undefined);\n    _classPrivateFieldInitSpec(_this, _camera, undefined);\n    _classPrivateFieldInitSpec(_this, _innerBackLayer, undefined);\n    _defineProperty(_this, \"minLevel\", undefined);\n    _defineProperty(_this, \"maxLevel\", undefined);\n    _defineProperty(_this, \"thresholds\", _toConsumableArray(new Array(30)).map(function (_, idx) {\n      return 8 / Math.pow(2, idx);\n    }));\n    // in terms of radius units\n    _defineProperty(_this, \"curvatureResolution\", 5);\n    // in degrees, affects number of vertices in tiles\n    _defineProperty(_this, \"tileMargin\", 0);\n    _defineProperty(_this, \"clearTiles\", function () {\n      Object.values(_classPrivateFieldGet2(_tilesMeta, _this)).forEach(function (l) {\n        l.forEach(function (d) {\n          if (d.obj) {\n            _this.remove(d.obj);\n            emptyObject(d.obj);\n            delete d.obj;\n          }\n        });\n      });\n      _classPrivateFieldSet2(_tilesMeta, _this, {});\n    });\n    _classPrivateFieldSet2(_radius, _this, radius);\n    _this.tileUrl = tileUrl;\n    _classPrivateFieldSet2(_isMercator, _this, mercatorProjection);\n    _this.minLevel = minLevel;\n    _this.maxLevel = maxLevel;\n    _this.level = 0;\n\n    // Add protective black sphere just below surface to prevent any depth buffer anomalies\n    _this.add(_classPrivateFieldSet2(_innerBackLayer, _this, new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(_classPrivateFieldGet2(_radius, _this) * 0.99, 180, 90), new three__WEBPACK_IMPORTED_MODULE_2__.MeshBasicMaterial({\n      color: 0x0\n    }))));\n    _classPrivateFieldGet2(_innerBackLayer, _this).visible = false;\n    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffset = true;\n    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetUnits = 3;\n    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetFactor = 1;\n    return _this;\n  }\n  _inherits(ThreeSlippyMapGlobe, _Group);\n  return _createClass(ThreeSlippyMapGlobe, [{\n    key: \"tileUrl\",\n    get:\n    // Public attributes\n    function get() {\n      return _classPrivateFieldGet2(_tileUrl, this);\n    },\n    set: function set(tileUrl) {\n      _classPrivateFieldSet2(_tileUrl, this, tileUrl);\n      this.updatePov(_classPrivateFieldGet2(_camera, this)); // update current view\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return _classPrivateFieldGet2(_level, this);\n    },\n    set: function set(level) {\n      var _this2 = this;\n      if (!_classPrivateFieldGet2(_tilesMeta, this)[level]) _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _buildMetaLevel).call(this, level);\n      var prevLevel = _classPrivateFieldGet2(_level, this);\n      _classPrivateFieldSet2(_level, this, level);\n      if (level === prevLevel || prevLevel === undefined) return; // nothing else to do\n\n      // Activate back layer for levels > 0, when there's !depthWrite tiles\n      _classPrivateFieldGet2(_innerBackLayer, this).visible = level > 0;\n\n      // Bring layer to front\n      _classPrivateFieldGet2(_tilesMeta, this)[level].forEach(function (d) {\n        return d.obj && (d.obj.material.depthWrite = true);\n      });\n\n      // push lower layers to background\n      prevLevel < level && _classPrivateFieldGet2(_tilesMeta, this)[prevLevel].forEach(function (d) {\n        return d.obj && (d.obj.material.depthWrite = false);\n      });\n\n      // Remove upper layers\n      if (prevLevel > level) {\n        for (var l = level + 1; l <= prevLevel; l++) {\n          _classPrivateFieldGet2(_tilesMeta, this)[l] && _classPrivateFieldGet2(_tilesMeta, this)[l].forEach(function (d) {\n            if (d.obj) {\n              _this2.remove(d.obj);\n              emptyObject(d.obj);\n              delete d.obj;\n            }\n          });\n        }\n      }\n      _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);\n    }\n\n    // Public methods\n  }, {\n    key: \"updatePov\",\n    value: function updatePov(camera) {\n      var _this3 = this;\n      if (!camera || !(camera instanceof three__WEBPACK_IMPORTED_MODULE_2__.Camera)) return;\n      _classPrivateFieldSet2(_camera, this, camera);\n      var frustum;\n      _classPrivateFieldSet2(_isInView, this, function (d) {\n        if (!d.hullPnts) {\n          // cached for next time to improve performance\n          var lngLen = 360 / Math.pow(2, _this3.level);\n          var lng = d.lng,\n            lat = d.lat,\n            latLen = d.latLen;\n          var lng0 = lng - lngLen / 2;\n          var lng1 = lng + lngLen / 2;\n          var lat0 = lat - latLen / 2;\n          var lat1 = lat + latLen / 2;\n          d.hullPnts = [[lat, lng], [lat0, lng0], [lat1, lng0], [lat0, lng1], [lat1, lng1]].map(function (_ref2) {\n            var _ref3 = _slicedToArray(_ref2, 2),\n              lat = _ref3[0],\n              lng = _ref3[1];\n            return polar2Cartesian(lat, lng, _classPrivateFieldGet2(_radius, _this3));\n          }).map(function (_ref4) {\n            var x = _ref4.x,\n              y = _ref4.y,\n              z = _ref4.z;\n            return new three__WEBPACK_IMPORTED_MODULE_2__.Vector3(x, y, z);\n          });\n        }\n        if (!frustum) {\n          frustum = new three__WEBPACK_IMPORTED_MODULE_2__.Frustum();\n          camera.updateMatrix();\n          camera.updateMatrixWorld();\n          frustum.setFromProjectionMatrix(new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));\n        }\n        return d.hullPnts.some(function (pos) {\n          return frustum.containsPoint(pos.clone().applyMatrix4(_this3.matrixWorld));\n        });\n      });\n      if (this.tileUrl) {\n        var pov = camera.position.clone();\n        var distToGlobeCenter = pov.distanceTo(this.getWorldPosition(new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()));\n        var cameraDistance = (distToGlobeCenter - _classPrivateFieldGet2(_radius, this)) / _classPrivateFieldGet2(_radius, this); // in units of globe radius\n\n        var idx = this.thresholds.findIndex(function (t) {\n          return t && t <= cameraDistance;\n        });\n        this.level = Math.min(this.maxLevel, Math.max(this.minLevel, idx < 0 ? this.thresholds.length : idx));\n        _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);\n      }\n    }\n  }]);\n}(three__WEBPACK_IMPORTED_MODULE_2__.Group);\nfunction _buildMetaLevel(level) {\n  var _this4 = this;\n  if (level > MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE) {\n    // Generate meta dynamically\n    _classPrivateFieldGet2(_tilesMeta, this)[level] = [];\n    return;\n  }\n\n  // Generate distance lookup octree\n  var levelMeta = _classPrivateFieldGet2(_tilesMeta, this)[level] = genTilesCoords(level, _classPrivateFieldGet2(_isMercator, this));\n  levelMeta.forEach(function (d) {\n    return d.centroid = polar2Cartesian(d.lat, d.lng, _classPrivateFieldGet2(_radius, _this4));\n  });\n  levelMeta.octree = (0,d3_octree__WEBPACK_IMPORTED_MODULE_3__[\"default\"])().x(function (d) {\n    return d.centroid.x;\n  }).y(function (d) {\n    return d.centroid.y;\n  }).z(function (d) {\n    return d.centroid.z;\n  }).addAll(levelMeta);\n}\nfunction _fetchNeededTiles() {\n  var _this5 = this;\n  if (!this.tileUrl || this.level === undefined || !_classPrivateFieldGet2(_tilesMeta, this).hasOwnProperty(this.level)) return;\n\n  // Safety if can't check in view tiles for higher levels\n  if (!_classPrivateFieldGet2(_isInView, this) && this.level > MAX_LEVEL_TO_RENDER_ALL_TILES) return;\n  var tiles = _classPrivateFieldGet2(_tilesMeta, this)[this.level];\n  if (_classPrivateFieldGet2(_camera, this)) {\n    // Pre-select tiles close to the camera\n    var povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());\n    if (tiles.octree) {\n      var _tiles$octree;\n      // Octree based on 3d positions is more accurate\n      var _povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());\n      var searchRadius = (_povPos.length() - _classPrivateFieldGet2(_radius, this)) * TILE_SEARCH_RADIUS_CAMERA_DISTANCE;\n      tiles = (_tiles$octree = tiles.octree).findAllWithinRadius.apply(_tiles$octree, _toConsumableArray(_povPos).concat([searchRadius]));\n    } else {\n      // tiles populated dynamically\n      var povCoords = cartesian2Polar(povPos);\n      var searchRadiusLat = (povCoords.r / _classPrivateFieldGet2(_radius, this) - 1) * TILE_SEARCH_RADIUS_SURFACE_DISTANCE;\n      var searchRadiusLng = searchRadiusLat / Math.cos(deg2Rad(povCoords.lat)); // Distances in longitude degrees shrink towards the poles\n      var lngRange = [povCoords.lng - searchRadiusLng, povCoords.lng + searchRadiusLng];\n      var latRange = [povCoords.lat + searchRadiusLat, povCoords.lat - searchRadiusLat];\n      var _findTileXY = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[0], latRange[0]),\n        _findTileXY2 = _slicedToArray(_findTileXY, 2),\n        x0 = _findTileXY2[0],\n        y0 = _findTileXY2[1];\n      var _findTileXY3 = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[1], latRange[1]),\n        _findTileXY4 = _slicedToArray(_findTileXY3, 2),\n        x1 = _findTileXY4[0],\n        y1 = _findTileXY4[1];\n      !tiles.record && (tiles.record = {}); // Index gen tiles by XY\n      var r = tiles.record;\n      if (!r.hasOwnProperty(\"\".concat(Math.round((x0 + x1) / 2), \"_\").concat(Math.round((y0 + y1) / 2)))) {\n        // gen all found tiles if middle one is not in record\n        tiles = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x0, y0, x1, y1).map(function (d) {\n          var k = \"\".concat(d.x, \"_\").concat(d.y);\n          if (r.hasOwnProperty(k)) return r[k];\n          r[k] = d;\n          tiles.push(d);\n          return d;\n        });\n      } else {\n        // gen only those missing, one by one\n        var selTiles = [];\n        for (var x = x0; x <= x1; x++) {\n          for (var y = y0; y <= y1; y++) {\n            var k = \"\".concat(x, \"_\").concat(y);\n            if (!r.hasOwnProperty(k)) {\n              r[k] = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x, y, x, y)[0];\n              tiles.push(r[k]);\n            }\n            selTiles.push(r[k]);\n          }\n        }\n        tiles = selTiles;\n      }\n    }\n  }\n\n  /*\n  console.log({\n    level: this.level,\n    totalObjs: this.children.length,\n    tilesFound: tiles.length,\n    tilesInView: tiles.filter(this.#isInView || (() => true)).length,\n    levelTiles: this.#tilesMeta[this.level].length,\n    fetched: this.#tilesMeta[this.level].filter(d => d.obj).length,\n    loading: this.#tilesMeta[this.level].filter(d => d.loading).length,\n  });\n  */\n\n  tiles.filter(function (d) {\n    return !d.obj;\n  }).filter(_classPrivateFieldGet2(_isInView, this) || function () {\n    return true;\n  }).forEach(function (d) {\n    var x = d.x,\n      y = d.y,\n      lng = d.lng,\n      lat = d.lat,\n      latLen = d.latLen;\n    var lngLen = 360 / Math.pow(2, _this5.level);\n    if (!d.obj) {\n      var width = lngLen * (1 - _this5.tileMargin);\n      var height = latLen * (1 - _this5.tileMargin);\n      var rotLng = deg2Rad(lng);\n      var rotLat = deg2Rad(-lat);\n      var tile = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(new three__WEBPACK_IMPORTED_MODULE_2__.SphereGeometry(_classPrivateFieldGet2(_radius, _this5), Math.ceil(width / _this5.curvatureResolution), Math.ceil(height / _this5.curvatureResolution), deg2Rad(90 - width / 2) + rotLng, deg2Rad(width), deg2Rad(90 - height / 2) + rotLat, deg2Rad(height)), new three__WEBPACK_IMPORTED_MODULE_2__.MeshLambertMaterial());\n      if (_classPrivateFieldGet2(_isMercator, _this5)) {\n        var _map = [lat + latLen / 2, lat - latLen / 2].map(function (lat) {\n            return 0.5 - lat / 180;\n          }),\n          _map2 = _slicedToArray(_map, 2),\n          _y = _map2[0],\n          _y2 = _map2[1];\n        convertMercatorUV(tile.geometry.attributes.uv, _y, _y2);\n      }\n      d.obj = tile;\n    }\n    if (!d.loading) {\n      d.loading = true;\n\n      // Fetch tile image\n      new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(_this5.tileUrl(x, y, _this5.level), function (texture) {\n        var tile = d.obj;\n        if (tile) {\n          texture.colorSpace = three__WEBPACK_IMPORTED_MODULE_2__.SRGBColorSpace;\n          tile.material.map = texture;\n          tile.material.color = null;\n          tile.material.needsUpdate = true;\n          _this5.add(tile);\n        }\n        d.loading = false;\n      });\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc2xpcHB5LW1hcC1nbG9iZS9kaXN0L3RocmVlLXNsaXBweS1tYXAtZ2xvYmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQThKO0FBQzNIO0FBQ0k7QUFDQzs7QUFFeEM7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZLGtFQUFrRTtBQUM3SCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNB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QkFBcUIsdUNBQUksS0FBSyxpREFBYyxvUEFBb1Asc0RBQW1CO0FBQ25UO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGdEQUFhO0FBQ3ZCO0FBQ0E7QUFDQSwrQkFBK0IsaURBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUUwQyIsInNvdXJjZXMiOlsiL1VzZXJzL3N1cmFqcmF3YXQvRG93bmxvYWRzL1RyaXB5L25vZGVfbW9kdWxlcy90aHJlZS1zbGlwcHktbWFwLWdsb2JlL2Rpc3QvdGhyZWUtc2xpcHB5LW1hcC1nbG9iZS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgR3JvdXAsIE1lc2gsIFNwaGVyZUdlb21ldHJ5LCBNZXNoQmFzaWNNYXRlcmlhbCwgQ2FtZXJhLCBWZWN0b3IzLCBGcnVzdHVtLCBNYXRyaXg0LCBNZXNoTGFtYmVydE1hdGVyaWFsLCBUZXh0dXJlTG9hZGVyLCBTUkdCQ29sb3JTcGFjZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IG9jdHJlZSB9IGZyb20gJ2QzLW9jdHJlZSc7XG5pbXBvcnQgeyBzY2FsZUxpbmVhciB9IGZyb20gJ2QzLXNjYWxlJztcbmltcG9ydCB7IGdlb01lcmNhdG9yUmF3IH0gZnJvbSAnZDMtZ2VvJztcblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7XG59XG5mdW5jdGlvbiBfYXNzZXJ0Q2xhc3NCcmFuZChlLCB0LCBuKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUgPyBlID09PSB0IDogZS5oYXModCkpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHQgOiBuO1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBlbGVtZW50IGlzIG5vdCBwcmVzZW50IG9uIHRoaXMgb2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChlKSB7XG4gIGlmICh1bmRlZmluZWQgPT09IGUpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5mdW5jdGlvbiBfY2hlY2tQcml2YXRlUmVkZWNsYXJhdGlvbihlLCB0KSB7XG4gIGlmICh0LmhhcyhlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBpbml0aWFsaXplIHRoZSBzYW1lIHByaXZhdGUgZWxlbWVudHMgdHdpY2Ugb24gYW4gb2JqZWN0XCIpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihzLCBhKSB7XG4gIHJldHVybiBzLmdldChfYXNzZXJ0Q2xhc3NCcmFuZChzLCBhKSk7XG59XG5mdW5jdGlvbiBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhlLCB0LCBhKSB7XG4gIF9jaGVja1ByaXZhdGVSZWRlY2xhcmF0aW9uKGUsIHQpLCB0LnNldChlLCBhKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIocywgYSwgcikge1xuICByZXR1cm4gcy5zZXQoX2Fzc2VydENsYXNzQnJhbmQocywgYSksIHIpLCByO1xufVxuZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZU1ldGhvZEluaXRTcGVjKGUsIGEpIHtcbiAgX2NoZWNrUHJpdmF0ZVJlZGVjbGFyYXRpb24oZSwgYSksIGEuYWRkKGUpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8IGZhbHNlLCBvLmNvbmZpZ3VyYWJsZSA9IHRydWUsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gdHJ1ZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIF9nZXRQcm90b3R5cGVPZih0KTtcbn1cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSB0KSB7XG4gICAgdmFyIGUsXG4gICAgICBuLFxuICAgICAgaSxcbiAgICAgIHUsXG4gICAgICBhID0gW10sXG4gICAgICBmID0gdHJ1ZSxcbiAgICAgIG8gPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgOyBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSB0cnVlLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdC5yZXR1cm4gJiYgKHUgPSB0LnJldHVybigpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHVuZGVmaW5lZCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHVuZGVmaW5lZCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChTdHJpbmcgKSh0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxudmFyIF9tYXRlcmlhbERpc3Bvc2UgPSBmdW5jdGlvbiBtYXRlcmlhbERpc3Bvc2UobWF0ZXJpYWwpIHtcbiAgaWYgKG1hdGVyaWFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBtYXRlcmlhbC5mb3JFYWNoKF9tYXRlcmlhbERpc3Bvc2UpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtYXRlcmlhbC5tYXApIHtcbiAgICAgIG1hdGVyaWFsLm1hcC5kaXNwb3NlKCk7XG4gICAgfVxuICAgIG1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgfVxufTtcbnZhciBfZGVhbGxvY2F0ZSA9IGZ1bmN0aW9uIGRlYWxsb2NhdGUob2JqKSB7XG4gIGlmIChvYmouZ2VvbWV0cnkpIHtcbiAgICBvYmouZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB9XG4gIGlmIChvYmoubWF0ZXJpYWwpIHtcbiAgICBfbWF0ZXJpYWxEaXNwb3NlKG9iai5tYXRlcmlhbCk7XG4gIH1cbiAgaWYgKG9iai50ZXh0dXJlKSB7XG4gICAgb2JqLnRleHR1cmUuZGlzcG9zZSgpO1xuICB9XG4gIGlmIChvYmouY2hpbGRyZW4pIHtcbiAgICBvYmouY2hpbGRyZW4uZm9yRWFjaChfZGVhbGxvY2F0ZSk7XG4gIH1cbn07XG52YXIgZW1wdHlPYmplY3QgPSBmdW5jdGlvbiBlbXB0eU9iamVjdChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouY2hpbGRyZW4pIHdoaWxlIChvYmouY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGNoaWxkT2JqID0gb2JqLmNoaWxkcmVuWzBdO1xuICAgIG9iai5yZW1vdmUoY2hpbGRPYmopO1xuICAgIF9kZWFsbG9jYXRlKGNoaWxkT2JqKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcG9sYXIyQ2FydGVzaWFuKGxhdCwgbG5nLCByKSB7XG4gIHZhciBwaGkgPSAoOTAgLSBsYXQpICogTWF0aC5QSSAvIDE4MDtcbiAgdmFyIHRoZXRhID0gKDkwIC0gbG5nKSAqIE1hdGguUEkgLyAxODA7XG4gIHJldHVybiB7XG4gICAgeDogciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogciAqIE1hdGguY29zKHBoaSksXG4gICAgejogciAqIE1hdGguc2luKHBoaSkgKiBNYXRoLnNpbih0aGV0YSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhcnRlc2lhbjJQb2xhcihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgIHkgPSBfcmVmLnksXG4gICAgeiA9IF9yZWYuejtcbiAgdmFyIHIgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgdmFyIHBoaSA9IE1hdGguYWNvcyh5IC8gcik7XG4gIHZhciB0aGV0YSA9IE1hdGguYXRhbjIoeiwgeCk7XG4gIHJldHVybiB7XG4gICAgbGF0OiA5MCAtIHBoaSAqIDE4MCAvIE1hdGguUEksXG4gICAgbG5nOiA5MCAtIHRoZXRhICogMTgwIC8gTWF0aC5QSSAtICh0aGV0YSA8IC1NYXRoLlBJIC8gMiA/IDM2MCA6IDApLFxuICAgIC8vIGtlZXAgd2l0aGluIFstMTgwLCAxODBdIGJvdW5kYXJpZXNcbiAgICByOiByXG4gIH07XG59XG5mdW5jdGlvbiBkZWcyUmFkKGRlZykge1xuICByZXR1cm4gZGVnICogTWF0aC5QSSAvIDE4MDtcbn1cblxudmFyIHlNZXJjYXRvclNjYWxlID0gZnVuY3Rpb24geU1lcmNhdG9yU2NhbGUoeSkge1xuICByZXR1cm4gMSAtIChnZW9NZXJjYXRvclJhdygwLCAoMC41IC0geSkgKiBNYXRoLlBJKVsxXSAvIE1hdGguUEkgKyAxKSAvIDI7XG59O1xudmFyIHlNZXJjYXRvclNjYWxlQ2xhbXBlZCA9IGZ1bmN0aW9uIHlNZXJjYXRvclNjYWxlQ2xhbXBlZCh5KSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB5TWVyY2F0b3JTY2FsZSh5KSkpO1xufTtcbnZhciB5TWVyY2F0b3JTY2FsZUludmVydCA9IGZ1bmN0aW9uIHlNZXJjYXRvclNjYWxlSW52ZXJ0KHkpIHtcbiAgcmV0dXJuIDAuNSAtIGdlb01lcmNhdG9yUmF3LmludmVydCgwLCAoMiAqICgxIC0geSkgLSAxKSAqIE1hdGguUEkpWzFdIC8gTWF0aC5QSTtcbn07XG52YXIgY29udmVydE1lcmNhdG9yVVYgPSBmdW5jdGlvbiBjb252ZXJ0TWVyY2F0b3JVVih1dnMpIHtcbiAgdmFyIHkwID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgeTEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHZhciBvZmZzZXRTY2FsZSA9IHNjYWxlTGluZWFyKCkuZG9tYWluKFsxLCAwXSkucmFuZ2UoW3kwLCB5MV0pLmNsYW1wKHRydWUpO1xuICB2YXIgcmV2T2Zmc2V0U2NhbGUgPSBzY2FsZUxpbmVhcigpLmRvbWFpbihbeU1lcmNhdG9yU2NhbGVDbGFtcGVkKHkwKSwgeU1lcmNhdG9yU2NhbGVDbGFtcGVkKHkxKV0pLnJhbmdlKFsxLCAwXSkuY2xhbXAodHJ1ZSk7XG4gIHZhciBzY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHYpIHtcbiAgICByZXR1cm4gcmV2T2Zmc2V0U2NhbGUoeU1lcmNhdG9yU2NhbGVDbGFtcGVkKG9mZnNldFNjYWxlKHYpKSk7XG4gIH07XG4gIHZhciBhcnIgPSB1dnMuYXJyYXk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBhcnJbaSArIDFdID0gc2NhbGUoYXJyW2kgKyAxXSk7XG4gIH1cbiAgdXZzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cbnZhciBmaW5kVGlsZVhZID0gZnVuY3Rpb24gZmluZFRpbGVYWShsZXZlbCwgaXNNZXJjYXRvciwgbG5nLCBsYXQpIHtcbiAgdmFyIGdyaWRTaXplID0gTWF0aC5wb3coMiwgbGV2ZWwpO1xuICB2YXIgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGdyaWRTaXplIC0gMSwgTWF0aC5mbG9vcigobG5nICsgMTgwKSAqIGdyaWRTaXplIC8gMzYwKSkpO1xuICB2YXIgcmVsWSA9ICg5MCAtIGxhdCkgLyAxODA7XG4gIGlzTWVyY2F0b3IgJiYgKHJlbFkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB5TWVyY2F0b3JTY2FsZShyZWxZKSkpKTtcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHJlbFkgKiBncmlkU2l6ZSk7XG4gIHJldHVybiBbeCwgeV07XG59O1xudmFyIGdlblRpbGVzQ29vcmRzID0gZnVuY3Rpb24gZ2VuVGlsZXNDb29yZHMobGV2ZWwsIGlzTWVyY2F0b3IpIHtcbiAgdmFyIHgwID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICB2YXIgeTAgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gIHZhciBfeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgdmFyIF95MSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ID8gYXJndW1lbnRzWzVdIDogdW5kZWZpbmVkO1xuICB2YXIgdGlsZXMgPSBbXTtcbiAgdmFyIGdyaWRTaXplID0gTWF0aC5wb3coMiwgbGV2ZWwpO1xuICB2YXIgdGlsZUxuZ0xlbiA9IDM2MCAvIGdyaWRTaXplO1xuICB2YXIgcmVnVGlsZUxhdExlbiA9IDE4MCAvIGdyaWRTaXplO1xuICB2YXIgeDEgPSBfeDEgPT09IHVuZGVmaW5lZCA/IGdyaWRTaXplIC0gMSA6IF94MTtcbiAgdmFyIHkxID0gX3kxID09PSB1bmRlZmluZWQgPyBncmlkU2l6ZSAtIDEgOiBfeTE7XG4gIGZvciAodmFyIHggPSB4MCwgbWF4WCA9IE1hdGgubWluKGdyaWRTaXplIC0gMSwgeDEpOyB4IDw9IG1heFg7IHgrKykge1xuICAgIGZvciAodmFyIHkgPSB5MCwgbWF4WSA9IE1hdGgubWluKGdyaWRTaXplIC0gMSwgeTEpOyB5IDw9IG1heFk7IHkrKykge1xuICAgICAgdmFyIHJlcHJvWSA9IHksXG4gICAgICAgIHRpbGVMYXRMZW4gPSByZWdUaWxlTGF0TGVuO1xuICAgICAgaWYgKGlzTWVyY2F0b3IpIHtcbiAgICAgICAgLy8gbGF0IG5lZWRzIHJlcHJvamVjdGlvbiwgYnV0IHN0cmV0Y2ggdG8gY292ZXIgcG9sZXNcbiAgICAgICAgcmVwcm9ZID0geSA9PT0gMCA/IHkgOiB5TWVyY2F0b3JTY2FsZUludmVydCh5IC8gZ3JpZFNpemUpICogZ3JpZFNpemU7XG4gICAgICAgIHZhciByZXByb1lFbmQgPSB5ICsgMSA9PT0gZ3JpZFNpemUgPyB5ICsgMSA6IHlNZXJjYXRvclNjYWxlSW52ZXJ0KCh5ICsgMSkgLyBncmlkU2l6ZSkgKiBncmlkU2l6ZTtcbiAgICAgICAgdGlsZUxhdExlbiA9IChyZXByb1lFbmQgLSByZXByb1kpICogMTgwIC8gZ3JpZFNpemU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRpbGUgY2VudHJvaWQgY29vcmRpbmF0ZXNcbiAgICAgIHZhciBsbmcgPSAtMTgwICsgKHggKyAwLjUpICogdGlsZUxuZ0xlbjtcbiAgICAgIHZhciBsYXQgPSA5MCAtIChyZXByb1kgKiAxODAgLyBncmlkU2l6ZSArIHRpbGVMYXRMZW4gLyAyKTtcbiAgICAgIHZhciBsYXRMZW4gPSB0aWxlTGF0TGVuOyAvLyBsbmcgaXMgYWx3YXlzIGNvbnN0YW50IGFtb25nIGFsbCB0aWxlc1xuXG4gICAgICB0aWxlcy5wdXNoKHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgbG5nOiBsbmcsXG4gICAgICAgIGxhdDogbGF0LFxuICAgICAgICBsYXRMZW46IGxhdExlblxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWxlcztcbn07XG5cbnZhciBNQVhfTEVWRUxfVE9fUkVOREVSX0FMTF9USUxFUyA9IDY7IC8vIGxldmVsIDYgPSA0MDk2IHRpbGVzXG52YXIgTUFYX0xFVkVMX1RPX0JVSUxEX0xPT0tVUF9PQ1RSRUUgPSA3OyAvLyBvY3RyZWVzIGNvbnN1bWUgdG9vIG11Y2ggbWVtb3J5IG9uIGhpZ2hlciBsZXZlbHMsIGdlbmVyYXRlIHRpbGVzIG9uIGRlbWFuZCBmb3IgdGhvc2UgKGJhc2VkIG9uIGdsb2JlIHN1cmZhY2UgZGlzdGFuY2UpIGFzIHRoZSBkaXN0b3J0aW9uIGlzIG5lZ2xpZ2libGVcbnZhciBUSUxFX1NFQVJDSF9SQURJVVNfQ0FNRVJBX0RJU1RBTkNFID0gMzsgLy8gRXVjbGlkZWFuIGRpc3RhbmNlIGZhY3RvciwgaW4gdW5pdHMgb2YgY2FtZXJhIGRpc3RhbmNlIHRvIHN1cmZhY2VcbnZhciBUSUxFX1NFQVJDSF9SQURJVVNfU1VSRkFDRV9ESVNUQU5DRSA9IDkwOyAvLyBpbiBkZWdyZWVzIG9uIHRoZSBnbG9iZSBzdXJmYWNlLCByZWxhdGl2ZSB0byBjYW1lcmEgYWx0aXR1ZGUgaW4gZ2xvYmUgcmFkaXVzIHVuaXRzXG52YXIgX3JhZGl1cyA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9pc01lcmNhdG9yID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX3RpbGVVcmwgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfbGV2ZWwgPSAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKTtcbnZhciBfdGlsZXNNZXRhID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX2lzSW5WaWV3ID0gLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG52YXIgX2NhbWVyYSA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9pbm5lckJhY2tMYXllciA9IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpO1xudmFyIF9UaHJlZVNsaXBweU1hcEdsb2JlX2JyYW5kID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG52YXIgVGhyZWVTbGlwcHlNYXBHbG9iZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyb3VwKSB7XG4gIGZ1bmN0aW9uIFRocmVlU2xpcHB5TWFwR2xvYmUocmFkaXVzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIHRpbGVVcmwgPSBfcmVmLnRpbGVVcmwsXG4gICAgICBfcmVmJG1pbkxldmVsID0gX3JlZi5taW5MZXZlbCxcbiAgICAgIG1pbkxldmVsID0gX3JlZiRtaW5MZXZlbCA9PT0gdW5kZWZpbmVkID8gMCA6IF9yZWYkbWluTGV2ZWwsXG4gICAgICBfcmVmJG1heExldmVsID0gX3JlZi5tYXhMZXZlbCxcbiAgICAgIG1heExldmVsID0gX3JlZiRtYXhMZXZlbCA9PT0gdW5kZWZpbmVkID8gMTcgOiBfcmVmJG1heExldmVsLFxuICAgICAgX3JlZiRtZXJjYXRvclByb2plY3RpID0gX3JlZi5tZXJjYXRvclByb2plY3Rpb24sXG4gICAgICBtZXJjYXRvclByb2plY3Rpb24gPSBfcmVmJG1lcmNhdG9yUHJvamVjdGkgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBfcmVmJG1lcmNhdG9yUHJvamVjdGk7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRocmVlU2xpcHB5TWFwR2xvYmUpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBUaHJlZVNsaXBweU1hcEdsb2JlKTtcbiAgICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgICBfY2xhc3NQcml2YXRlTWV0aG9kSW5pdFNwZWMoX3RoaXMsIF9UaHJlZVNsaXBweU1hcEdsb2JlX2JyYW5kKTtcbiAgICAvLyBQcml2YXRlIGF0dHJpYnV0ZXNcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX3JhZGl1cywgdW5kZWZpbmVkKTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2lzTWVyY2F0b3IsIHVuZGVmaW5lZCk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF90aWxlVXJsLCB1bmRlZmluZWQpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfbGV2ZWwsIHVuZGVmaW5lZCk7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkSW5pdFNwZWMoX3RoaXMsIF90aWxlc01ldGEsIHt9KTtcbiAgICBfY2xhc3NQcml2YXRlRmllbGRJbml0U3BlYyhfdGhpcywgX2lzSW5WaWV3LCB1bmRlZmluZWQpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfY2FtZXJhLCB1bmRlZmluZWQpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEluaXRTcGVjKF90aGlzLCBfaW5uZXJCYWNrTGF5ZXIsIHVuZGVmaW5lZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1pbkxldmVsXCIsIHVuZGVmaW5lZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1heExldmVsXCIsIHVuZGVmaW5lZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInRocmVzaG9sZHNcIiwgX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBBcnJheSgzMCkpLm1hcChmdW5jdGlvbiAoXywgaWR4KSB7XG4gICAgICByZXR1cm4gOCAvIE1hdGgucG93KDIsIGlkeCk7XG4gICAgfSkpO1xuICAgIC8vIGluIHRlcm1zIG9mIHJhZGl1cyB1bml0c1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjdXJ2YXR1cmVSZXNvbHV0aW9uXCIsIDUpO1xuICAgIC8vIGluIGRlZ3JlZXMsIGFmZmVjdHMgbnVtYmVyIG9mIHZlcnRpY2VzIGluIHRpbGVzXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInRpbGVNYXJnaW5cIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNsZWFyVGlsZXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgT2JqZWN0LnZhbHVlcyhfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIF90aGlzKSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICBsLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZC5vYmopIHtcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZShkLm9iaik7XG4gICAgICAgICAgICBlbXB0eU9iamVjdChkLm9iaik7XG4gICAgICAgICAgICBkZWxldGUgZC5vYmo7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfdGlsZXNNZXRhLCBfdGhpcywge30pO1xuICAgIH0pO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX3JhZGl1cywgX3RoaXMsIHJhZGl1cyk7XG4gICAgX3RoaXMudGlsZVVybCA9IHRpbGVVcmw7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfaXNNZXJjYXRvciwgX3RoaXMsIG1lcmNhdG9yUHJvamVjdGlvbik7XG4gICAgX3RoaXMubWluTGV2ZWwgPSBtaW5MZXZlbDtcbiAgICBfdGhpcy5tYXhMZXZlbCA9IG1heExldmVsO1xuICAgIF90aGlzLmxldmVsID0gMDtcblxuICAgIC8vIEFkZCBwcm90ZWN0aXZlIGJsYWNrIHNwaGVyZSBqdXN0IGJlbG93IHN1cmZhY2UgdG8gcHJldmVudCBhbnkgZGVwdGggYnVmZmVyIGFub21hbGllc1xuICAgIF90aGlzLmFkZChfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9pbm5lckJhY2tMYXllciwgX3RoaXMsIG5ldyBNZXNoKG5ldyBTcGhlcmVHZW9tZXRyeShfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIF90aGlzKSAqIDAuOTksIDE4MCwgOTApLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICAgICAgY29sb3I6IDB4MFxuICAgIH0pKSkpO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCBfdGhpcykudmlzaWJsZSA9IGZhbHNlO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCBfdGhpcykubWF0ZXJpYWwucG9seWdvbk9mZnNldCA9IHRydWU7XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaW5uZXJCYWNrTGF5ZXIsIF90aGlzKS5tYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAzO1xuICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCBfdGhpcykubWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciA9IDE7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhUaHJlZVNsaXBweU1hcEdsb2JlLCBfR3JvdXApO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRocmVlU2xpcHB5TWFwR2xvYmUsIFt7XG4gICAga2V5OiBcInRpbGVVcmxcIixcbiAgICBnZXQ6XG4gICAgLy8gUHVibGljIGF0dHJpYnV0ZXNcbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZVVybCwgdGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0aWxlVXJsKSB7XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF90aWxlVXJsLCB0aGlzLCB0aWxlVXJsKTtcbiAgICAgIHRoaXMudXBkYXRlUG92KF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2NhbWVyYSwgdGhpcykpOyAvLyB1cGRhdGUgY3VycmVudCB2aWV3XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxldmVsXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfbGV2ZWwsIHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobGV2ZWwpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCFfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW2xldmVsXSkgX2Fzc2VydENsYXNzQnJhbmQoX1RocmVlU2xpcHB5TWFwR2xvYmVfYnJhbmQsIHRoaXMsIF9idWlsZE1ldGFMZXZlbCkuY2FsbCh0aGlzLCBsZXZlbCk7XG4gICAgICB2YXIgcHJldkxldmVsID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfbGV2ZWwsIHRoaXMpO1xuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkU2V0MihfbGV2ZWwsIHRoaXMsIGxldmVsKTtcbiAgICAgIGlmIChsZXZlbCA9PT0gcHJldkxldmVsIHx8IHByZXZMZXZlbCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG5vdGhpbmcgZWxzZSB0byBkb1xuXG4gICAgICAvLyBBY3RpdmF0ZSBiYWNrIGxheWVyIGZvciBsZXZlbHMgPiAwLCB3aGVuIHRoZXJlJ3MgIWRlcHRoV3JpdGUgdGlsZXNcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lubmVyQmFja0xheWVyLCB0aGlzKS52aXNpYmxlID0gbGV2ZWwgPiAwO1xuXG4gICAgICAvLyBCcmluZyBsYXllciB0byBmcm9udFxuICAgICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsZXZlbF0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5vYmogJiYgKGQub2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSB0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwdXNoIGxvd2VyIGxheWVycyB0byBiYWNrZ3JvdW5kXG4gICAgICBwcmV2TGV2ZWwgPCBsZXZlbCAmJiBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW3ByZXZMZXZlbF0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5vYmogJiYgKGQub2JqLm1hdGVyaWFsLmRlcHRoV3JpdGUgPSBmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVtb3ZlIHVwcGVyIGxheWVyc1xuICAgICAgaWYgKHByZXZMZXZlbCA+IGxldmVsKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBsZXZlbCArIDE7IGwgPD0gcHJldkxldmVsOyBsKyspIHtcbiAgICAgICAgICBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW2xdICYmIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcylbbF0uZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgaWYgKGQub2JqKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5yZW1vdmUoZC5vYmopO1xuICAgICAgICAgICAgICBlbXB0eU9iamVjdChkLm9iaik7XG4gICAgICAgICAgICAgIGRlbGV0ZSBkLm9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX2Fzc2VydENsYXNzQnJhbmQoX1RocmVlU2xpcHB5TWFwR2xvYmVfYnJhbmQsIHRoaXMsIF9mZXRjaE5lZWRlZFRpbGVzKS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFB1YmxpYyBtZXRob2RzXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlUG92XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBvdihjYW1lcmEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKCFjYW1lcmEgfHwgIShjYW1lcmEgaW5zdGFuY2VvZiBDYW1lcmEpKSByZXR1cm47XG4gICAgICBfY2xhc3NQcml2YXRlRmllbGRTZXQyKF9jYW1lcmEsIHRoaXMsIGNhbWVyYSk7XG4gICAgICB2YXIgZnJ1c3R1bTtcbiAgICAgIF9jbGFzc1ByaXZhdGVGaWVsZFNldDIoX2lzSW5WaWV3LCB0aGlzLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICBpZiAoIWQuaHVsbFBudHMpIHtcbiAgICAgICAgICAvLyBjYWNoZWQgZm9yIG5leHQgdGltZSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgdmFyIGxuZ0xlbiA9IDM2MCAvIE1hdGgucG93KDIsIF90aGlzMy5sZXZlbCk7XG4gICAgICAgICAgdmFyIGxuZyA9IGQubG5nLFxuICAgICAgICAgICAgbGF0ID0gZC5sYXQsXG4gICAgICAgICAgICBsYXRMZW4gPSBkLmxhdExlbjtcbiAgICAgICAgICB2YXIgbG5nMCA9IGxuZyAtIGxuZ0xlbiAvIDI7XG4gICAgICAgICAgdmFyIGxuZzEgPSBsbmcgKyBsbmdMZW4gLyAyO1xuICAgICAgICAgIHZhciBsYXQwID0gbGF0IC0gbGF0TGVuIC8gMjtcbiAgICAgICAgICB2YXIgbGF0MSA9IGxhdCArIGxhdExlbiAvIDI7XG4gICAgICAgICAgZC5odWxsUG50cyA9IFtbbGF0LCBsbmddLCBbbGF0MCwgbG5nMF0sIFtsYXQxLCBsbmcwXSwgW2xhdDAsIGxuZzFdLCBbbGF0MSwgbG5nMV1dLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMyA9IF9zbGljZWRUb0FycmF5KF9yZWYyLCAyKSxcbiAgICAgICAgICAgICAgbGF0ID0gX3JlZjNbMF0sXG4gICAgICAgICAgICAgIGxuZyA9IF9yZWYzWzFdO1xuICAgICAgICAgICAgcmV0dXJuIHBvbGFyMkNhcnRlc2lhbihsYXQsIGxuZywgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCBfdGhpczMpKTtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9yZWY0LngsXG4gICAgICAgICAgICAgIHkgPSBfcmVmNC55LFxuICAgICAgICAgICAgICB6ID0gX3JlZjQuejtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yMyh4LCB5LCB6KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZydXN0dW0pIHtcbiAgICAgICAgICBmcnVzdHVtID0gbmV3IEZydXN0dW0oKTtcbiAgICAgICAgICBjYW1lcmEudXBkYXRlTWF0cml4KCk7XG4gICAgICAgICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgICAgZnJ1c3R1bS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChuZXcgTWF0cml4NCgpLm11bHRpcGx5TWF0cmljZXMoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZC5odWxsUG50cy5zb21lKGZ1bmN0aW9uIChwb3MpIHtcbiAgICAgICAgICByZXR1cm4gZnJ1c3R1bS5jb250YWluc1BvaW50KHBvcy5jbG9uZSgpLmFwcGx5TWF0cml4NChfdGhpczMubWF0cml4V29ybGQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmICh0aGlzLnRpbGVVcmwpIHtcbiAgICAgICAgdmFyIHBvdiA9IGNhbWVyYS5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgICB2YXIgZGlzdFRvR2xvYmVDZW50ZXIgPSBwb3YuZGlzdGFuY2VUbyh0aGlzLmdldFdvcmxkUG9zaXRpb24obmV3IFZlY3RvcjMoKSkpO1xuICAgICAgICB2YXIgY2FtZXJhRGlzdGFuY2UgPSAoZGlzdFRvR2xvYmVDZW50ZXIgLSBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIHRoaXMpKSAvIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgdGhpcyk7IC8vIGluIHVuaXRzIG9mIGdsb2JlIHJhZGl1c1xuXG4gICAgICAgIHZhciBpZHggPSB0aGlzLnRocmVzaG9sZHMuZmluZEluZGV4KGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHQgJiYgdCA8PSBjYW1lcmFEaXN0YW5jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBNYXRoLm1pbih0aGlzLm1heExldmVsLCBNYXRoLm1heCh0aGlzLm1pbkxldmVsLCBpZHggPCAwID8gdGhpcy50aHJlc2hvbGRzLmxlbmd0aCA6IGlkeCkpO1xuICAgICAgICBfYXNzZXJ0Q2xhc3NCcmFuZChfVGhyZWVTbGlwcHlNYXBHbG9iZV9icmFuZCwgdGhpcywgX2ZldGNoTmVlZGVkVGlsZXMpLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KEdyb3VwKTtcbmZ1bmN0aW9uIF9idWlsZE1ldGFMZXZlbChsZXZlbCkge1xuICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgaWYgKGxldmVsID4gTUFYX0xFVkVMX1RPX0JVSUxEX0xPT0tVUF9PQ1RSRUUpIHtcbiAgICAvLyBHZW5lcmF0ZSBtZXRhIGR5bmFtaWNhbGx5XG4gICAgX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVtsZXZlbF0gPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBkaXN0YW5jZSBsb29rdXAgb2N0cmVlXG4gIHZhciBsZXZlbE1ldGEgPSBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF90aWxlc01ldGEsIHRoaXMpW2xldmVsXSA9IGdlblRpbGVzQ29vcmRzKGxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSk7XG4gIGxldmVsTWV0YS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuY2VudHJvaWQgPSBwb2xhcjJDYXJ0ZXNpYW4oZC5sYXQsIGQubG5nLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9yYWRpdXMsIF90aGlzNCkpO1xuICB9KTtcbiAgbGV2ZWxNZXRhLm9jdHJlZSA9IG9jdHJlZSgpLngoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gZC5jZW50cm9pZC54O1xuICB9KS55KGZ1bmN0aW9uIChkKSB7XG4gICAgcmV0dXJuIGQuY2VudHJvaWQueTtcbiAgfSkueihmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBkLmNlbnRyb2lkLno7XG4gIH0pLmFkZEFsbChsZXZlbE1ldGEpO1xufVxuZnVuY3Rpb24gX2ZldGNoTmVlZGVkVGlsZXMoKSB7XG4gIHZhciBfdGhpczUgPSB0aGlzO1xuICBpZiAoIXRoaXMudGlsZVVybCB8fCB0aGlzLmxldmVsID09PSB1bmRlZmluZWQgfHwgIV9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3RpbGVzTWV0YSwgdGhpcykuaGFzT3duUHJvcGVydHkodGhpcy5sZXZlbCkpIHJldHVybjtcblxuICAvLyBTYWZldHkgaWYgY2FuJ3QgY2hlY2sgaW4gdmlldyB0aWxlcyBmb3IgaGlnaGVyIGxldmVsc1xuICBpZiAoIV9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzSW5WaWV3LCB0aGlzKSAmJiB0aGlzLmxldmVsID4gTUFYX0xFVkVMX1RPX1JFTkRFUl9BTExfVElMRVMpIHJldHVybjtcbiAgdmFyIHRpbGVzID0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfdGlsZXNNZXRhLCB0aGlzKVt0aGlzLmxldmVsXTtcbiAgaWYgKF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2NhbWVyYSwgdGhpcykpIHtcbiAgICAvLyBQcmUtc2VsZWN0IHRpbGVzIGNsb3NlIHRvIHRoZSBjYW1lcmFcbiAgICB2YXIgcG92UG9zID0gdGhpcy53b3JsZFRvTG9jYWwoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfY2FtZXJhLCB0aGlzKS5wb3NpdGlvbi5jbG9uZSgpKTtcbiAgICBpZiAodGlsZXMub2N0cmVlKSB7XG4gICAgICB2YXIgX3RpbGVzJG9jdHJlZTtcbiAgICAgIC8vIE9jdHJlZSBiYXNlZCBvbiAzZCBwb3NpdGlvbnMgaXMgbW9yZSBhY2N1cmF0ZVxuICAgICAgdmFyIF9wb3ZQb3MgPSB0aGlzLndvcmxkVG9Mb2NhbChfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9jYW1lcmEsIHRoaXMpLnBvc2l0aW9uLmNsb25lKCkpO1xuICAgICAgdmFyIHNlYXJjaFJhZGl1cyA9IChfcG92UG9zLmxlbmd0aCgpIC0gX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfcmFkaXVzLCB0aGlzKSkgKiBUSUxFX1NFQVJDSF9SQURJVVNfQ0FNRVJBX0RJU1RBTkNFO1xuICAgICAgdGlsZXMgPSAoX3RpbGVzJG9jdHJlZSA9IHRpbGVzLm9jdHJlZSkuZmluZEFsbFdpdGhpblJhZGl1cy5hcHBseShfdGlsZXMkb2N0cmVlLCBfdG9Db25zdW1hYmxlQXJyYXkoX3BvdlBvcykuY29uY2F0KFtzZWFyY2hSYWRpdXNdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRpbGVzIHBvcHVsYXRlZCBkeW5hbWljYWxseVxuICAgICAgdmFyIHBvdkNvb3JkcyA9IGNhcnRlc2lhbjJQb2xhcihwb3ZQb3MpO1xuICAgICAgdmFyIHNlYXJjaFJhZGl1c0xhdCA9IChwb3ZDb29yZHMuciAvIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgdGhpcykgLSAxKSAqIFRJTEVfU0VBUkNIX1JBRElVU19TVVJGQUNFX0RJU1RBTkNFO1xuICAgICAgdmFyIHNlYXJjaFJhZGl1c0xuZyA9IHNlYXJjaFJhZGl1c0xhdCAvIE1hdGguY29zKGRlZzJSYWQocG92Q29vcmRzLmxhdCkpOyAvLyBEaXN0YW5jZXMgaW4gbG9uZ2l0dWRlIGRlZ3JlZXMgc2hyaW5rIHRvd2FyZHMgdGhlIHBvbGVzXG4gICAgICB2YXIgbG5nUmFuZ2UgPSBbcG92Q29vcmRzLmxuZyAtIHNlYXJjaFJhZGl1c0xuZywgcG92Q29vcmRzLmxuZyArIHNlYXJjaFJhZGl1c0xuZ107XG4gICAgICB2YXIgbGF0UmFuZ2UgPSBbcG92Q29vcmRzLmxhdCArIHNlYXJjaFJhZGl1c0xhdCwgcG92Q29vcmRzLmxhdCAtIHNlYXJjaFJhZGl1c0xhdF07XG4gICAgICB2YXIgX2ZpbmRUaWxlWFkgPSBmaW5kVGlsZVhZKHRoaXMubGV2ZWwsIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzTWVyY2F0b3IsIHRoaXMpLCBsbmdSYW5nZVswXSwgbGF0UmFuZ2VbMF0pLFxuICAgICAgICBfZmluZFRpbGVYWTIgPSBfc2xpY2VkVG9BcnJheShfZmluZFRpbGVYWSwgMiksXG4gICAgICAgIHgwID0gX2ZpbmRUaWxlWFkyWzBdLFxuICAgICAgICB5MCA9IF9maW5kVGlsZVhZMlsxXTtcbiAgICAgIHZhciBfZmluZFRpbGVYWTMgPSBmaW5kVGlsZVhZKHRoaXMubGV2ZWwsIF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX2lzTWVyY2F0b3IsIHRoaXMpLCBsbmdSYW5nZVsxXSwgbGF0UmFuZ2VbMV0pLFxuICAgICAgICBfZmluZFRpbGVYWTQgPSBfc2xpY2VkVG9BcnJheShfZmluZFRpbGVYWTMsIDIpLFxuICAgICAgICB4MSA9IF9maW5kVGlsZVhZNFswXSxcbiAgICAgICAgeTEgPSBfZmluZFRpbGVYWTRbMV07XG4gICAgICAhdGlsZXMucmVjb3JkICYmICh0aWxlcy5yZWNvcmQgPSB7fSk7IC8vIEluZGV4IGdlbiB0aWxlcyBieSBYWVxuICAgICAgdmFyIHIgPSB0aWxlcy5yZWNvcmQ7XG4gICAgICBpZiAoIXIuaGFzT3duUHJvcGVydHkoXCJcIi5jb25jYXQoTWF0aC5yb3VuZCgoeDAgKyB4MSkgLyAyKSwgXCJfXCIpLmNvbmNhdChNYXRoLnJvdW5kKCh5MCArIHkxKSAvIDIpKSkpIHtcbiAgICAgICAgLy8gZ2VuIGFsbCBmb3VuZCB0aWxlcyBpZiBtaWRkbGUgb25lIGlzIG5vdCBpbiByZWNvcmRcbiAgICAgICAgdGlsZXMgPSBnZW5UaWxlc0Nvb3Jkcyh0aGlzLmxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSwgeDAsIHkwLCB4MSwgeTEpLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHZhciBrID0gXCJcIi5jb25jYXQoZC54LCBcIl9cIikuY29uY2F0KGQueSk7XG4gICAgICAgICAgaWYgKHIuaGFzT3duUHJvcGVydHkoaykpIHJldHVybiByW2tdO1xuICAgICAgICAgIHJba10gPSBkO1xuICAgICAgICAgIHRpbGVzLnB1c2goZCk7XG4gICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZ2VuIG9ubHkgdGhvc2UgbWlzc2luZywgb25lIGJ5IG9uZVxuICAgICAgICB2YXIgc2VsVGlsZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeCA9IHgwOyB4IDw9IHgxOyB4KyspIHtcbiAgICAgICAgICBmb3IgKHZhciB5ID0geTA7IHkgPD0geTE7IHkrKykge1xuICAgICAgICAgICAgdmFyIGsgPSBcIlwiLmNvbmNhdCh4LCBcIl9cIikuY29uY2F0KHkpO1xuICAgICAgICAgICAgaWYgKCFyLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgIHJba10gPSBnZW5UaWxlc0Nvb3Jkcyh0aGlzLmxldmVsLCBfY2xhc3NQcml2YXRlRmllbGRHZXQyKF9pc01lcmNhdG9yLCB0aGlzKSwgeCwgeSwgeCwgeSlbMF07XG4gICAgICAgICAgICAgIHRpbGVzLnB1c2gocltrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxUaWxlcy5wdXNoKHJba10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aWxlcyA9IHNlbFRpbGVzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gIGNvbnNvbGUubG9nKHtcbiAgICBsZXZlbDogdGhpcy5sZXZlbCxcbiAgICB0b3RhbE9ianM6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoLFxuICAgIHRpbGVzRm91bmQ6IHRpbGVzLmxlbmd0aCxcbiAgICB0aWxlc0luVmlldzogdGlsZXMuZmlsdGVyKHRoaXMuI2lzSW5WaWV3IHx8ICgoKSA9PiB0cnVlKSkubGVuZ3RoLFxuICAgIGxldmVsVGlsZXM6IHRoaXMuI3RpbGVzTWV0YVt0aGlzLmxldmVsXS5sZW5ndGgsXG4gICAgZmV0Y2hlZDogdGhpcy4jdGlsZXNNZXRhW3RoaXMubGV2ZWxdLmZpbHRlcihkID0+IGQub2JqKS5sZW5ndGgsXG4gICAgbG9hZGluZzogdGhpcy4jdGlsZXNNZXRhW3RoaXMubGV2ZWxdLmZpbHRlcihkID0+IGQubG9hZGluZykubGVuZ3RoLFxuICB9KTtcbiAgKi9cblxuICB0aWxlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4gIWQub2JqO1xuICB9KS5maWx0ZXIoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNJblZpZXcsIHRoaXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIHZhciB4ID0gZC54LFxuICAgICAgeSA9IGQueSxcbiAgICAgIGxuZyA9IGQubG5nLFxuICAgICAgbGF0ID0gZC5sYXQsXG4gICAgICBsYXRMZW4gPSBkLmxhdExlbjtcbiAgICB2YXIgbG5nTGVuID0gMzYwIC8gTWF0aC5wb3coMiwgX3RoaXM1LmxldmVsKTtcbiAgICBpZiAoIWQub2JqKSB7XG4gICAgICB2YXIgd2lkdGggPSBsbmdMZW4gKiAoMSAtIF90aGlzNS50aWxlTWFyZ2luKTtcbiAgICAgIHZhciBoZWlnaHQgPSBsYXRMZW4gKiAoMSAtIF90aGlzNS50aWxlTWFyZ2luKTtcbiAgICAgIHZhciByb3RMbmcgPSBkZWcyUmFkKGxuZyk7XG4gICAgICB2YXIgcm90TGF0ID0gZGVnMlJhZCgtbGF0KTtcbiAgICAgIHZhciB0aWxlID0gbmV3IE1lc2gobmV3IFNwaGVyZUdlb21ldHJ5KF9jbGFzc1ByaXZhdGVGaWVsZEdldDIoX3JhZGl1cywgX3RoaXM1KSwgTWF0aC5jZWlsKHdpZHRoIC8gX3RoaXM1LmN1cnZhdHVyZVJlc29sdXRpb24pLCBNYXRoLmNlaWwoaGVpZ2h0IC8gX3RoaXM1LmN1cnZhdHVyZVJlc29sdXRpb24pLCBkZWcyUmFkKDkwIC0gd2lkdGggLyAyKSArIHJvdExuZywgZGVnMlJhZCh3aWR0aCksIGRlZzJSYWQoOTAgLSBoZWlnaHQgLyAyKSArIHJvdExhdCwgZGVnMlJhZChoZWlnaHQpKSwgbmV3IE1lc2hMYW1iZXJ0TWF0ZXJpYWwoKSk7XG4gICAgICBpZiAoX2NsYXNzUHJpdmF0ZUZpZWxkR2V0MihfaXNNZXJjYXRvciwgX3RoaXM1KSkge1xuICAgICAgICB2YXIgX21hcCA9IFtsYXQgKyBsYXRMZW4gLyAyLCBsYXQgLSBsYXRMZW4gLyAyXS5tYXAoZnVuY3Rpb24gKGxhdCkge1xuICAgICAgICAgICAgcmV0dXJuIDAuNSAtIGxhdCAvIDE4MDtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfbWFwMiA9IF9zbGljZWRUb0FycmF5KF9tYXAsIDIpLFxuICAgICAgICAgIF95ID0gX21hcDJbMF0sXG4gICAgICAgICAgX3kyID0gX21hcDJbMV07XG4gICAgICAgIGNvbnZlcnRNZXJjYXRvclVWKHRpbGUuZ2VvbWV0cnkuYXR0cmlidXRlcy51diwgX3ksIF95Mik7XG4gICAgICB9XG4gICAgICBkLm9iaiA9IHRpbGU7XG4gICAgfVxuICAgIGlmICghZC5sb2FkaW5nKSB7XG4gICAgICBkLmxvYWRpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBGZXRjaCB0aWxlIGltYWdlXG4gICAgICBuZXcgVGV4dHVyZUxvYWRlcigpLmxvYWQoX3RoaXM1LnRpbGVVcmwoeCwgeSwgX3RoaXM1LmxldmVsKSwgZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIHRpbGUgPSBkLm9iajtcbiAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICB0ZXh0dXJlLmNvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZTtcbiAgICAgICAgICB0aWxlLm1hdGVyaWFsLm1hcCA9IHRleHR1cmU7XG4gICAgICAgICAgdGlsZS5tYXRlcmlhbC5jb2xvciA9IG51bGw7XG4gICAgICAgICAgdGlsZS5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgX3RoaXM1LmFkZCh0aWxlKTtcbiAgICAgICAgfVxuICAgICAgICBkLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFRocmVlU2xpcHB5TWFwR2xvYmUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs\n");

/***/ })

};
;