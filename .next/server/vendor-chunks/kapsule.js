"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/kapsule";
exports.ids = ["vendor-chunks/kapsule"];
exports.modules = {

/***/ "(ssr)/./node_modules/kapsule/dist/kapsule.mjs":
/*!***********************************************!*\
  !*** ./node_modules/kapsule/dist/kapsule.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var lodash_es_debounce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es/debounce.js */ \"(ssr)/./node_modules/lodash-es/debounce.js\");\n\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar Prop = /*#__PURE__*/_createClass(function Prop(name, _ref) {\n  var _ref$default = _ref[\"default\"],\n    defaultVal = _ref$default === void 0 ? null : _ref$default,\n    _ref$triggerUpdate = _ref.triggerUpdate,\n    triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate,\n    _ref$onChange = _ref.onChange,\n    onChange = _ref$onChange === void 0 ? function (newVal, state) {} : _ref$onChange;\n  _classCallCheck(this, Prop);\n  this.name = name;\n  this.defaultVal = defaultVal;\n  this.triggerUpdate = triggerUpdate;\n  this.onChange = onChange;\n});\nfunction index (_ref2) {\n  var _ref2$stateInit = _ref2.stateInit,\n    stateInit = _ref2$stateInit === void 0 ? function () {\n      return {};\n    } : _ref2$stateInit,\n    _ref2$props = _ref2.props,\n    rawProps = _ref2$props === void 0 ? {} : _ref2$props,\n    _ref2$methods = _ref2.methods,\n    methods = _ref2$methods === void 0 ? {} : _ref2$methods,\n    _ref2$aliases = _ref2.aliases,\n    aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases,\n    _ref2$init = _ref2.init,\n    initFn = _ref2$init === void 0 ? function () {} : _ref2$init,\n    _ref2$update = _ref2.update,\n    updateFn = _ref2$update === void 0 ? function () {} : _ref2$update;\n  // Parse props into Prop instances\n  var props = Object.keys(rawProps).map(function (propName) {\n    return new Prop(propName, rawProps[propName]);\n  });\n  return function KapsuleComp() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var classMode = !!(this instanceof KapsuleComp ? this.constructor : void 0);\n    var nodeElement = classMode ? args.shift() : undefined;\n    var _args$ = args[0],\n      options = _args$ === void 0 ? {} : _args$;\n\n    // Holds component state\n    var state = Object.assign({}, stateInit instanceof Function ? stateInit(options) : stateInit,\n    // Support plain objects for backwards compatibility\n    {\n      initialised: false\n    });\n\n    // keeps track of which props triggered an update\n    var changedProps = {};\n\n    // Component constructor\n    function comp(nodeElement) {\n      initStatic(nodeElement, options);\n      digest();\n      return comp;\n    }\n    var initStatic = function initStatic(nodeElement, options) {\n      initFn.call(comp, nodeElement, state, options);\n      state.initialised = true;\n    };\n    var digest = (0,lodash_es_debounce_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(function () {\n      if (!state.initialised) {\n        return;\n      }\n      updateFn.call(comp, state, changedProps);\n      changedProps = {};\n    }, 1);\n\n    // Getter/setter methods\n    props.forEach(function (prop) {\n      comp[prop.name] = getSetProp(prop);\n      function getSetProp(_ref3) {\n        var prop = _ref3.name,\n          _ref3$triggerUpdate = _ref3.triggerUpdate,\n          redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate,\n          _ref3$onChange = _ref3.onChange,\n          onChange = _ref3$onChange === void 0 ? function (newVal, state) {} : _ref3$onChange,\n          _ref3$defaultVal = _ref3.defaultVal,\n          defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;\n        return function (_) {\n          var curVal = state[prop];\n          if (!arguments.length) {\n            return curVal;\n          } // Getter mode\n\n          var val = _ === undefined ? defaultVal : _; // pick default if value passed is undefined\n          state[prop] = val;\n          onChange.call(comp, val, state, curVal);\n\n          // track changed props\n          !changedProps.hasOwnProperty(prop) && (changedProps[prop] = curVal);\n          if (redigest) {\n            digest();\n          }\n          return comp;\n        };\n      }\n    });\n\n    // Other methods\n    Object.keys(methods).forEach(function (methodName) {\n      comp[methodName] = function () {\n        var _methods$methodName;\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args));\n      };\n    });\n\n    // Link aliases\n    Object.entries(aliases).forEach(function (_ref4) {\n      var _ref5 = _slicedToArray(_ref4, 2),\n        alias = _ref5[0],\n        target = _ref5[1];\n      return comp[alias] = comp[target];\n    });\n\n    // Reset all component props to their default value\n    comp.resetProps = function () {\n      props.forEach(function (prop) {\n        comp[prop.name](prop.defaultVal);\n      });\n      return comp;\n    };\n\n    //\n\n    comp.resetProps(); // Apply all prop defaults\n    state._rerender = digest; // Expose digest method\n\n    classMode && nodeElement && comp(nodeElement);\n    return comp;\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMva2Fwc3VsZS9kaXN0L2thcHN1bGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDOztBQUU3QztBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWSxrRUFBa0U7QUFDN0gsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJDQUEyQztBQUMzQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3RUFBd0UsYUFBYTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUVBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUI7QUFDdkIsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFNEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdXJhanJhd2F0L0Rvd25sb2Fkcy9UcmlweS9ub2RlX21vZHVsZXMva2Fwc3VsZS9kaXN0L2thcHN1bGUubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWJvdW5jZSBmcm9tICdsb2Rhc2gtZXMvZGVib3VuY2UuanMnO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIDsgZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gdHJ1ZSwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIFByb3AgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZUNsYXNzKGZ1bmN0aW9uIFByb3AobmFtZSwgX3JlZikge1xuICB2YXIgX3JlZiRkZWZhdWx0ID0gX3JlZltcImRlZmF1bHRcIl0sXG4gICAgZGVmYXVsdFZhbCA9IF9yZWYkZGVmYXVsdCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkZGVmYXVsdCxcbiAgICBfcmVmJHRyaWdnZXJVcGRhdGUgPSBfcmVmLnRyaWdnZXJVcGRhdGUsXG4gICAgdHJpZ2dlclVwZGF0ZSA9IF9yZWYkdHJpZ2dlclVwZGF0ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkdHJpZ2dlclVwZGF0ZSxcbiAgICBfcmVmJG9uQ2hhbmdlID0gX3JlZi5vbkNoYW5nZSxcbiAgICBvbkNoYW5nZSA9IF9yZWYkb25DaGFuZ2UgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChuZXdWYWwsIHN0YXRlKSB7fSA6IF9yZWYkb25DaGFuZ2U7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9wKTtcbiAgdGhpcy5uYW1lID0gbmFtZTtcbiAgdGhpcy5kZWZhdWx0VmFsID0gZGVmYXVsdFZhbDtcbiAgdGhpcy50cmlnZ2VyVXBkYXRlID0gdHJpZ2dlclVwZGF0ZTtcbiAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xufSk7XG5mdW5jdGlvbiBpbmRleCAoX3JlZjIpIHtcbiAgdmFyIF9yZWYyJHN0YXRlSW5pdCA9IF9yZWYyLnN0YXRlSW5pdCxcbiAgICBzdGF0ZUluaXQgPSBfcmVmMiRzdGF0ZUluaXQgPT09IHZvaWQgMCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9IDogX3JlZjIkc3RhdGVJbml0LFxuICAgIF9yZWYyJHByb3BzID0gX3JlZjIucHJvcHMsXG4gICAgcmF3UHJvcHMgPSBfcmVmMiRwcm9wcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMiRwcm9wcyxcbiAgICBfcmVmMiRtZXRob2RzID0gX3JlZjIubWV0aG9kcyxcbiAgICBtZXRob2RzID0gX3JlZjIkbWV0aG9kcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMiRtZXRob2RzLFxuICAgIF9yZWYyJGFsaWFzZXMgPSBfcmVmMi5hbGlhc2VzLFxuICAgIGFsaWFzZXMgPSBfcmVmMiRhbGlhc2VzID09PSB2b2lkIDAgPyB7fSA6IF9yZWYyJGFsaWFzZXMsXG4gICAgX3JlZjIkaW5pdCA9IF9yZWYyLmluaXQsXG4gICAgaW5pdEZuID0gX3JlZjIkaW5pdCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcmVmMiRpbml0LFxuICAgIF9yZWYyJHVwZGF0ZSA9IF9yZWYyLnVwZGF0ZSxcbiAgICB1cGRhdGVGbiA9IF9yZWYyJHVwZGF0ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcmVmMiR1cGRhdGU7XG4gIC8vIFBhcnNlIHByb3BzIGludG8gUHJvcCBpbnN0YW5jZXNcbiAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMocmF3UHJvcHMpLm1hcChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb3AocHJvcE5hbWUsIHJhd1Byb3BzW3Byb3BOYW1lXSk7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gS2Fwc3VsZUNvbXAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICB2YXIgY2xhc3NNb2RlID0gISEodGhpcyBpbnN0YW5jZW9mIEthcHN1bGVDb21wID8gdGhpcy5jb25zdHJ1Y3RvciA6IHZvaWQgMCk7XG4gICAgdmFyIG5vZGVFbGVtZW50ID0gY2xhc3NNb2RlID8gYXJncy5zaGlmdCgpIDogdW5kZWZpbmVkO1xuICAgIHZhciBfYXJncyQgPSBhcmdzWzBdLFxuICAgICAgb3B0aW9ucyA9IF9hcmdzJCA9PT0gdm9pZCAwID8ge30gOiBfYXJncyQ7XG5cbiAgICAvLyBIb2xkcyBjb21wb25lbnQgc3RhdGVcbiAgICB2YXIgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZUluaXQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHN0YXRlSW5pdChvcHRpb25zKSA6IHN0YXRlSW5pdCxcbiAgICAvLyBTdXBwb3J0IHBsYWluIG9iamVjdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAge1xuICAgICAgaW5pdGlhbGlzZWQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvLyBrZWVwcyB0cmFjayBvZiB3aGljaCBwcm9wcyB0cmlnZ2VyZWQgYW4gdXBkYXRlXG4gICAgdmFyIGNoYW5nZWRQcm9wcyA9IHt9O1xuXG4gICAgLy8gQ29tcG9uZW50IGNvbnN0cnVjdG9yXG4gICAgZnVuY3Rpb24gY29tcChub2RlRWxlbWVudCkge1xuICAgICAgaW5pdFN0YXRpYyhub2RlRWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICBkaWdlc3QoKTtcbiAgICAgIHJldHVybiBjb21wO1xuICAgIH1cbiAgICB2YXIgaW5pdFN0YXRpYyA9IGZ1bmN0aW9uIGluaXRTdGF0aWMobm9kZUVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGluaXRGbi5jYWxsKGNvbXAsIG5vZGVFbGVtZW50LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgICBzdGF0ZS5pbml0aWFsaXNlZCA9IHRydWU7XG4gICAgfTtcbiAgICB2YXIgZGlnZXN0ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzdGF0ZS5pbml0aWFsaXNlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cGRhdGVGbi5jYWxsKGNvbXAsIHN0YXRlLCBjaGFuZ2VkUHJvcHMpO1xuICAgICAgY2hhbmdlZFByb3BzID0ge307XG4gICAgfSwgMSk7XG5cbiAgICAvLyBHZXR0ZXIvc2V0dGVyIG1ldGhvZHNcbiAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICBjb21wW3Byb3AubmFtZV0gPSBnZXRTZXRQcm9wKHByb3ApO1xuICAgICAgZnVuY3Rpb24gZ2V0U2V0UHJvcChfcmVmMykge1xuICAgICAgICB2YXIgcHJvcCA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgX3JlZjMkdHJpZ2dlclVwZGF0ZSA9IF9yZWYzLnRyaWdnZXJVcGRhdGUsXG4gICAgICAgICAgcmVkaWdlc3QgPSBfcmVmMyR0cmlnZ2VyVXBkYXRlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJHRyaWdnZXJVcGRhdGUsXG4gICAgICAgICAgX3JlZjMkb25DaGFuZ2UgPSBfcmVmMy5vbkNoYW5nZSxcbiAgICAgICAgICBvbkNoYW5nZSA9IF9yZWYzJG9uQ2hhbmdlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobmV3VmFsLCBzdGF0ZSkge30gOiBfcmVmMyRvbkNoYW5nZSxcbiAgICAgICAgICBfcmVmMyRkZWZhdWx0VmFsID0gX3JlZjMuZGVmYXVsdFZhbCxcbiAgICAgICAgICBkZWZhdWx0VmFsID0gX3JlZjMkZGVmYXVsdFZhbCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYzJGRlZmF1bHRWYWw7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgICAgICAgIHZhciBjdXJWYWwgPSBzdGF0ZVtwcm9wXTtcbiAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJWYWw7XG4gICAgICAgICAgfSAvLyBHZXR0ZXIgbW9kZVxuXG4gICAgICAgICAgdmFyIHZhbCA9IF8gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWwgOiBfOyAvLyBwaWNrIGRlZmF1bHQgaWYgdmFsdWUgcGFzc2VkIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIHN0YXRlW3Byb3BdID0gdmFsO1xuICAgICAgICAgIG9uQ2hhbmdlLmNhbGwoY29tcCwgdmFsLCBzdGF0ZSwgY3VyVmFsKTtcblxuICAgICAgICAgIC8vIHRyYWNrIGNoYW5nZWQgcHJvcHNcbiAgICAgICAgICAhY2hhbmdlZFByb3BzLmhhc093blByb3BlcnR5KHByb3ApICYmIChjaGFuZ2VkUHJvcHNbcHJvcF0gPSBjdXJWYWwpO1xuICAgICAgICAgIGlmIChyZWRpZ2VzdCkge1xuICAgICAgICAgICAgZGlnZXN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gT3RoZXIgbWV0aG9kc1xuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgIGNvbXBbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfbWV0aG9kcyRtZXRob2ROYW1lO1xuICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfbWV0aG9kcyRtZXRob2ROYW1lID0gbWV0aG9kc1ttZXRob2ROYW1lXSkuY2FsbC5hcHBseShfbWV0aG9kcyRtZXRob2ROYW1lLCBbY29tcCwgc3RhdGVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTGluayBhbGlhc2VzXG4gICAgT2JqZWN0LmVudHJpZXMoYWxpYXNlcykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAyKSxcbiAgICAgICAgYWxpYXMgPSBfcmVmNVswXSxcbiAgICAgICAgdGFyZ2V0ID0gX3JlZjVbMV07XG4gICAgICByZXR1cm4gY29tcFthbGlhc10gPSBjb21wW3RhcmdldF07XG4gICAgfSk7XG5cbiAgICAvLyBSZXNldCBhbGwgY29tcG9uZW50IHByb3BzIHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVcbiAgICBjb21wLnJlc2V0UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGNvbXBbcHJvcC5uYW1lXShwcm9wLmRlZmF1bHRWYWwpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9O1xuXG4gICAgLy9cblxuICAgIGNvbXAucmVzZXRQcm9wcygpOyAvLyBBcHBseSBhbGwgcHJvcCBkZWZhdWx0c1xuICAgIHN0YXRlLl9yZXJlbmRlciA9IGRpZ2VzdDsgLy8gRXhwb3NlIGRpZ2VzdCBtZXRob2RcblxuICAgIGNsYXNzTW9kZSAmJiBub2RlRWxlbWVudCAmJiBjb21wKG5vZGVFbGVtZW50KTtcbiAgICByZXR1cm4gY29tcDtcbiAgfTtcbn1cblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/kapsule/dist/kapsule.mjs\n");

/***/ })

};
;